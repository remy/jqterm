{
  "headline": "jq 1.6 Manual",
  "history": "\n*The manual for the development version of jq can be found\n[here](/jq/manual).*\n",
  "body": "\nA jq program is a \"filter\": it takes an input, and produces an\noutput. There are a lot of builtin filters for extracting a\nparticular field of an object, or converting a number to a string,\nor various other standard tasks.\n\nFilters can be combined in various ways - you can pipe the output of\none filter into another filter, or collect the output of a filter\ninto an array.\n\nSome filters produce multiple results, for instance there's one that\nproduces all the elements of its input array. Piping that filter\ninto a second runs the second filter for each element of the\narray. Generally, things that would be done with loops and iteration\nin other languages are just done by gluing filters together in jq.\n\nIt's important to remember that every filter has an input and an\noutput. Even literals like \"hello\" or 42 are filters - they take an\ninput but always produce the same literal as output. Operations that\ncombine two filters, like addition, generally feed the same input to\nboth and combine the results. So, you can implement an averaging\nfilter as `add / length` - feeding the input array both to the `add`\nfilter and the `length` filter and then performing the division.\n\nBut that's getting ahead of ourselves. :) Let's start with something\nsimpler:\n",
  "manpage_intro": "jq(1) -- Command-line JSON processor\n====================================\n\n## SYNOPSIS\n\n`jq` [<options>...] <filter> [<files>...]\n\n`jq` can transform JSON in various ways, by selecting, iterating,\nreducing and otherwise mangling JSON documents. For instance,\nrunning the command `jq 'map(.price) | add'` will take an array of\nJSON objects as input and return the sum of their \"price\" fields.\n\n`jq` can accept text input as well, but by default, `jq` reads a\nstream of JSON entities (including numbers and other literals) from\n`stdin`. Whitespace is only needed to separate entities such as 1\nand 2, and true and false.  One or more <files> may be specified, in\nwhich case `jq` will read input from those instead.\n\nThe <options> are described in the [INVOKING JQ] section; they\nmostly concern input and output formatting. The <filter> is written\nin the jq language and specifies how to transform the input\nfile or document.\n\n## FILTERS\n",
  "manpage_epilogue": "## BUGS\n\nPresumably. Report them or discuss them at:\n\n    https://github.com/stedolan/jq/issues\n\n## AUTHOR\n\nStephen Dolan `<mu@netsoc.tcd.ie>`\n",
  "sections": [
    {
      "title": "Invoking jq",
      "body": "\njq filters run on a stream of JSON data. The input to jq is\nparsed as a sequence of whitespace-separated JSON values which\nare passed through the provided filter one at a time. The\noutput(s) of the filter are written to standard out, again as a\nsequence of whitespace-separated JSON data.\n\nNote: it is important to mind the shell's quoting rules.  As a\ngeneral rule it's best to always quote (with single-quote\ncharacters) the jq program, as too many characters with special\nmeaning to jq are also shell meta-characters.  For example, `jq\n\"foo\"` will fail on most Unix shells because that will be the same\nas `jq foo`, which will generally fail because `foo is not\ndefined`.  When using the Windows command shell (cmd.exe) it's\nbest to use double quotes around your jq program when given on the\ncommand-line (instead of the `-f program-file` option), but then\ndouble-quotes in the jq program need backslash escaping.\n\nYou can affect how jq reads and writes its input and output\nusing some command-line options:\n\n* `--version`:\n\n  Output the jq version and exit with zero.\n\n* `--seq`:\n\n  Use the `application/json-seq` MIME type scheme for separating\n  JSON texts in jq's input and output.  This means that an ASCII\n  RS (record separator) character is printed before each value on\n  output and an ASCII LF (line feed) is printed after every\n  output.  Input JSON texts that fail to parse are ignored (but\n  warned about), discarding all subsequent input until the next\n  RS.  This mode also parses the output of jq without the `--seq`\n  option.\n\n* `--stream`:\n\n  Parse the input in streaming fashion, outputing arrays of path\n  and leaf values (scalars and empty arrays or empty objects).\n  For example, `\"a\"` becomes `[[],\"a\"]`, and `[[],\"a\",[\"b\"]]`\n  becomes `[[0],[]]`, `[[1],\"a\"]`, and `[[1,0],\"b\"]`.\n\n  This is useful for processing very large inputs.  Use this in\n  conjunction with filtering and the `reduce` and `foreach` syntax\n  to reduce large inputs incrementally.\n\n* `--slurp`/`-s`:\n\n  Instead of running the filter for each JSON object in the\n  input, read the entire input stream into a large array and run\n  the filter just once.\n\n* `--raw-input`/`-R`:\n\n  Don't parse the input as JSON. Instead, each line of text is\n  passed to the filter as a string. If combined with `--slurp`,\n  then the entire input is passed to the filter as a single long\n  string.\n\n* `--null-input`/`-n`:\n\n  Don't read any input at all! Instead, the filter is run once\n  using `null` as the input. This is useful when using jq as a\n  simple calculator or to construct JSON data from scratch.\n\n* `--compact-output` / `-c`:\n\n  By default, jq pretty-prints JSON output. Using this option\n  will result in more compact output by instead putting each\n  JSON object on a single line.\n\n* `--tab`:\n\n  Use a tab for each indentation level instead of two spaces.\n\n* `--indent n`:\n\n  Use the given number of spaces (no more than 8) for indentation.\n\n* `--color-output` / `-C` and `--monochrome-output` / `-M`:\n\n  By default, jq outputs colored JSON if writing to a\n  terminal. You can force it to produce color even if writing to\n  a pipe or a file using `-C`, and disable color with `-M`.\n\n  Colors can be configured with the `JQ_COLORS` environment\n  variable (see below).\n\n* `--ascii-output` / `-a`:\n\n  jq usually outputs non-ASCII Unicode codepoints as UTF-8, even\n  if the input specified them as escape sequences (like\n  \"\\u03bc\"). Using this option, you can force jq to produce pure\n  ASCII output with every non-ASCII character replaced with the\n  equivalent escape sequence.\n\n* `--unbuffered`\n\n  Flush the output after each JSON object is printed (useful if\n  you're piping a slow data source into jq and piping jq's\n  output elsewhere).\n\n* `--sort-keys` / `-S`:\n\n  Output the fields of each object with the keys in sorted order.\n\n* `--raw-output` / `-r`:\n\n  With this option, if the filter's result is a string then it\n  will be written directly to standard output rather than being\n  formatted as a JSON string with quotes. This can be useful for\n  making jq filters talk to non-JSON-based systems.\n\n* `--join-output` / `-j`:\n\n  Like `-r` but jq won't print a newline after each output.\n\n* `-f filename` / `--from-file filename`:\n\n  Read filter from the file rather than from a command line, like\n  awk's -f option. You can also use '#' to make comments.\n\n* `-Ldirectory` / `-L directory`:\n\n  Prepend `directory` to the search list for modules.  If this\n  option is used then no builtin search list is used.  See the\n  section on modules below.\n\n* `-e` / `--exit-status`:\n\n  Sets the exit status of jq to 0 if the last output values was\n  neither `false` nor `null`, 1 if the last output value was\n  either `false` or `null`, or 4 if no valid result was ever\n  produced.  Normally jq exits with 2 if there was any usage\n  problem or system error, 3 if there was a jq program compile\n  error, or 0 if the jq program ran.\n\n  Another way to set the exit status is with the `halt_error`\n  builtin function.\n\n* `--arg name value`:\n\n  This option passes a value to the jq program as a predefined\n  variable. If you run jq with `--arg foo bar`, then `$foo` is\n  available in the program and has the value `\"bar\"`. Note that\n  `value` will be treated as a string, so `--arg foo 123` will\n  bind `$foo` to `\"123\"`.\n\n  Named arguments are also available to the jq program as\n  `$ARGS.named`.\n\n* `--argjson name JSON-text`:\n\n  This option passes a JSON-encoded value to the jq program as a\n  predefined variable. If you run jq with `--argjson foo 123`, then\n  `$foo` is available in the program and has the value `123`.\n\n* `--slurpfile variable-name filename`:\n\n  This option reads all the JSON texts in the named file and binds\n  an array of the parsed JSON values to the given global variable.\n  If you run jq with `--slurpfile foo bar`, then `$foo` is available\n  in the program and has an array whose elements correspond to the\n  texts in the file named `bar`.\n\n* `--rawfile variable-name filename`:\n\n  This option reads in the named file and binds its contents to the given\n  global variable.  If you run jq with `--rawfile foo bar`, then `$foo` is\n  available in the program and has a string whose contents are to the texs\n  in the file named `bar`.\n\n* `--argfile variable-name filename`:\n\n  Do not use.  Use `--slurpfile` instead.\n\n  (This option is like `--slurpfile`, but when the file has just\n  one text, then that is used, else an array of texts is used as\n  in `--slurpfile`.)\n\n* `--args`:\n\n  Remaining arguments are positional string arguments.  These are\n  available to the jq program as `$ARGS.positional[]`.\n\n* `--jsonargs`:\n\n  Remaining arguments are positional JSON text arguments.  These\n  are available to the jq program as `$ARGS.positional[]`.\n\n* `--run-tests [filename]`:\n\n  Runs the tests in the given file or standard input.  This must\n  be the last option given and does not honor all preceding\n  options.  The input consists of comment lines, empty lines, and\n  program lines followed by one input line, as many lines of\n  output as are expected (one per output), and a terminating empty\n  line.  Compilation failure tests start with a line containing\n  only \"%%FAIL\", then a line containing the program to compile,\n  then a line containing an error message to compare to the\n  actual.\n\n  Be warned that this option can change backwards-incompatibly.\n"
    },
    {
      "title": "Basic filters",
      "entries": [
        {
          "title": "Identity: `.`",
          "body": "\nThe absolute simplest filter is `.` .  This is a filter that\ntakes its input and produces it unchanged as output.  That is,\nthis is the identity operator.\n\nSince jq by default pretty-prints all output, this trivial\nprogram can be a useful way of formatting JSON output from,\nsay, `curl`.\n",
          "examples": [
            {
              "program": ".",
              "input": "\"Hello, world!\"",
              "output": [
                "\"Hello, world!\""
              ]
            }
          ]
        },
        {
          "title": "Object Identifier-Index: `.foo`, `.foo.bar`",
          "body": "\nThe simplest *useful* filter is `.foo`. When given a\nJSON object (aka dictionary or hash) as input, it produces\nthe value at the key \"foo\", or null if there's none present.\n\nA filter of the form `.foo.bar` is equivalent to `.foo|.bar`.\n\nThis syntax only works for simple, identifier-like keys, that\nis, keys that are all made of alphanumeric characters and\nunderscore, and which do not start with a digit.\n\nIf the key contains special characters, you need to surround\nit with double quotes like this: `.\"foo$\"`, or else `.[\"foo$\"]`.\n\nFor example `.[\"foo::bar\"]` and `.[\"foo.bar\"]` work while\n`.foo::bar` does not, and `.foo.bar` means `.[\"foo\"].[\"bar\"]`.\n",
          "examples": [
            {
              "program": ".foo",
              "input": "{\"foo\": 42, \"bar\": \"less interesting data\"}",
              "output": [
                42
              ]
            },
            {
              "program": ".foo",
              "input": "{\"notfoo\": true, \"alsonotfoo\": false}",
              "output": [
                "null"
              ]
            },
            {
              "program": ".[\"foo\"]",
              "input": "{\"foo\": 42}",
              "output": [
                42
              ]
            }
          ]
        },
        {
          "title": "Optional Object Identifier-Index: `.foo?`",
          "body": "\nJust like `.foo`, but does not output even an error when `.`\nis not an array or an object.\n",
          "examples": [
            {
              "program": ".foo?",
              "input": "{\"foo\": 42, \"bar\": \"less interesting data\"}",
              "output": [
                42
              ]
            },
            {
              "program": ".foo?",
              "input": "{\"notfoo\": true, \"alsonotfoo\": false}",
              "output": [
                "null"
              ]
            },
            {
              "program": ".[\"foo\"]?",
              "input": "{\"foo\": 42}",
              "output": [
                42
              ]
            },
            {
              "program": "[.foo?]",
              "input": "[1,2]",
              "output": [
                "[]"
              ]
            }
          ]
        },
        {
          "title": "Generic Object Index: `.[<string>]`",
          "body": "\nYou can also look up fields of an object using syntax like\n`.[\"foo\"]` (.foo above is a shorthand version of this, but\nonly for identifier-like strings).\n"
        },
        {
          "title": "Array Index: `.[2]`",
          "body": "\nWhen the index value is an integer, `.[<value>]` can index\narrays.  Arrays are zero-based, so `.[2]` returns the third\nelement.\n\nNegative indices are allowed, with -1 referring to the last\nelement, -2 referring to the next to last element, and so on.\n",
          "examples": [
            {
              "program": ".[0]",
              "input": "[{\"name\":\"JSON\", \"good\":true}, {\"name\":\"XML\", \"good\":false}]",
              "output": [
                "{\"name\":\"JSON\", \"good\":true}"
              ]
            },
            {
              "program": ".[2]",
              "input": "[{\"name\":\"JSON\", \"good\":true}, {\"name\":\"XML\", \"good\":false}]",
              "output": [
                "null"
              ]
            },
            {
              "program": ".[-2]",
              "input": "[1,2,3]",
              "output": [
                "2"
              ]
            }
          ]
        },
        {
          "title": "Array/String Slice: `.[10:15]`",
          "body": "\nThe `.[10:15]` syntax can be used to return a subarray of an\narray or substring of a string. The array returned by\n`.[10:15]` will be of length 5, containing the elements from\nindex 10 (inclusive) to index 15 (exclusive). Either index may\nbe negative (in which case it counts backwards from the end of\nthe array), or omitted (in which case it refers to the start\nor end of the array).\n",
          "examples": [
            {
              "program": ".[2:4]",
              "input": "[\"a\",\"b\",\"c\",\"d\",\"e\"]",
              "output": [
                "[\"c\", \"d\"]"
              ]
            },
            {
              "program": ".[2:4]",
              "input": "\"abcdefghi\"",
              "output": [
                "\"cd\""
              ]
            },
            {
              "program": ".[:3]",
              "input": "[\"a\",\"b\",\"c\",\"d\",\"e\"]",
              "output": [
                "[\"a\", \"b\", \"c\"]"
              ]
            },
            {
              "program": ".[-2:]",
              "input": "[\"a\",\"b\",\"c\",\"d\",\"e\"]",
              "output": [
                "[\"d\", \"e\"]"
              ]
            }
          ]
        },
        {
          "title": "Array/Object Value Iterator: `.[]`",
          "body": "\nIf you use the `.[index]` syntax, but omit the index\nentirely, it will return *all* of the elements of an\narray. Running `.[]` with the input `[1,2,3]` will produce the\nnumbers as three separate results, rather than as a single\narray.\n\nYou can also use this on an object, and it will return all\nthe values of the object.\n",
          "examples": [
            {
              "program": ".[]",
              "input": "[{\"name\":\"JSON\", \"good\":true}, {\"name\":\"XML\", \"good\":false}]",
              "output": [
                "{\"name\":\"JSON\", \"good\":true}",
                "{\"name\":\"XML\", \"good\":false}"
              ]
            },
            {
              "program": ".[]",
              "input": "[]",
              "output": []
            },
            {
              "program": ".[]",
              "input": "{\"a\": 1, \"b\": 1}",
              "output": [
                "1",
                "1"
              ]
            }
          ]
        },
        {
          "title": "`.[]?`",
          "body": "\nLike `.[]`, but no errors will be output if . is not an array\nor object.\n"
        },
        {
          "title": "Comma: `,`",
          "body": "\nIf two filters are separated by a comma, then the\nsame input will be fed into both and the two filters' output\nvalue streams will be concatenated in order: first, all of the\noutputs produced by the left expression, and then all of the\noutputs produced by the right. For instance, filter `.foo,\n.bar`, produces both the \"foo\" fields and \"bar\" fields as\nseparate outputs.\n",
          "examples": [
            {
              "program": ".foo, .bar",
              "input": "{\"foo\": 42, \"bar\": \"something else\", \"baz\": true}",
              "output": [
                "42",
                "\"something else\""
              ]
            },
            {
              "program": ".user, .projects[]",
              "input": "{\"user\":\"stedolan\", \"projects\": [\"jq\", \"wikiflow\"]}",
              "output": [
                "\"stedolan\"",
                "\"jq\"",
                "\"wikiflow\""
              ]
            },
            {
              "program": ".[4,2]",
              "input": "[\"a\",\"b\",\"c\",\"d\",\"e\"]",
              "output": [
                "\"e\"",
                "\"c\""
              ]
            }
          ]
        },
        {
          "title": "Pipe: `|`",
          "body": "\nThe | operator combines two filters by feeding the output(s) of\nthe one on the left into the input of the one on the right. It's\npretty much the same as the Unix shell's pipe, if you're used to\nthat.\n\nIf the one on the left produces multiple results, the one on\nthe right will be run for each of those results. So, the\nexpression `.[] | .foo` retrieves the \"foo\" field of each\nelement of the input array.\n\nNote that `.a.b.c` is the same as `.a | .b | .c`.\n\nNote too that `.` is the input value at the particular stage\nin a \"pipeline\", specifically: where the `.` expression appears.\nThus `.a | . | .b` is the same as `.a.b`, as the `.` in the\nmiddle refers to whatever value `.a` produced.\n",
          "examples": [
            {
              "program": ".[] | .name",
              "input": "[{\"name\":\"JSON\", \"good\":true}, {\"name\":\"XML\", \"good\":false}]",
              "output": [
                "\"JSON\"",
                "\"XML\""
              ]
            }
          ]
        },
        {
          "title": "Parenthesis",
          "body": "\nParenthesis work as a grouping operator just as in any typical\nprogramming language.\n",
          "examples": [
            {
              "program": "(. + 2) * 5",
              "input": "1",
              "output": [
                15
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "Types and Values",
      "body": "\njq supports the same set of datatypes as JSON - numbers,\nstrings, booleans, arrays, objects (which in JSON-speak are\nhashes with only string keys), and \"null\".\n\nBooleans, null, strings and numbers are written the same way as\nin javascript. Just like everything else in jq, these simple\nvalues take an input and produce an output - `42` is a valid jq\nexpression that takes an input, ignores it, and returns 42\ninstead.\n",
      "entries": [
        {
          "title": "Array construction: `[]`",
          "body": "\nAs in JSON, `[]` is used to construct arrays, as in\n`[1,2,3]`. The elements of the arrays can be any jq\nexpression, including a pipeline. All of the results produced\nby all of the expressions are collected into one big array.\nYou can use it to construct an array out of a known quantity\nof values (as in `[.foo, .bar, .baz]`) or to \"collect\" all the\nresults of a filter into an array (as in `[.items[].name]`)\n\nOnce you understand the \",\" operator, you can look at jq's array\nsyntax in a different light: the expression `[1,2,3]` is not using a\nbuilt-in syntax for comma-separated arrays, but is instead applying\nthe `[]` operator (collect results) to the expression 1,2,3 (which\nproduces three different results).\n\nIf you have a filter `X` that produces four results,\nthen the expression `[X]` will produce a single result, an\narray of four elements.\n",
          "examples": [
            {
              "program": "[.user, .projects[]]",
              "input": "{\"user\":\"stedolan\", \"projects\": [\"jq\", \"wikiflow\"]}",
              "output": [
                "[\"stedolan\", \"jq\", \"wikiflow\"]"
              ]
            },
            {
              "program": "[ .[] | . * 2]",
              "input": "[1, 2, 3]",
              "output": [
                "[2, 4, 6]"
              ]
            }
          ]
        },
        {
          "title": "Object Construction: `{}`",
          "body": "\nLike JSON, `{}` is for constructing objects (aka\ndictionaries or hashes), as in: `{\"a\": 42, \"b\": 17}`.\n\nIf the keys are \"identifier-like\", then the quotes can be left\noff, as in `{a:42, b:17}`.  Keys generated by expressions need\nto be parenthesized, e.g., `{(\"a\"+\"b\"):59}`.\n\nThe value can be any expression (although you may need to\nwrap it in parentheses if it's a complicated one), which gets\napplied to the {} expression's input (remember, all filters\nhave an input and an output).\n\n    {foo: .bar}\n\nwill produce the JSON object `{\"foo\": 42}` if given the JSON\nobject `{\"bar\":42, \"baz\":43}` as its input. You can use this\nto select particular fields of an object: if the input is an\nobject with \"user\", \"title\", \"id\", and \"content\" fields and\nyou just want \"user\" and \"title\", you can write\n\n    {user: .user, title: .title}\n\nBecause that is so common, there's a shortcut syntax for it:\n`{user, title}`.\n\nIf one of the expressions produces multiple results,\nmultiple dictionaries will be produced. If the input's\n\n    {\"user\":\"stedolan\",\"titles\":[\"JQ Primer\", \"More JQ\"]}\n\nthen the expression\n\n    {user, title: .titles[]}\n\nwill produce two outputs:\n\n    {\"user\":\"stedolan\", \"title\": \"JQ Primer\"}\n    {\"user\":\"stedolan\", \"title\": \"More JQ\"}\n\nPutting parentheses around the key means it will be evaluated as an\nexpression. With the same input as above,\n\n    {(.user): .titles}\n\nproduces\n\n    {\"stedolan\": [\"JQ Primer\", \"More JQ\"]}\n",
          "examples": [
            {
              "program": "{user, title: .titles[]}",
              "input": "{\"user\":\"stedolan\",\"titles\":[\"JQ Primer\", \"More JQ\"]}",
              "output": [
                "{\"user\":\"stedolan\", \"title\": \"JQ Primer\"}",
                "{\"user\":\"stedolan\", \"title\": \"More JQ\"}"
              ]
            },
            {
              "program": "{(.user): .titles}",
              "input": "{\"user\":\"stedolan\",\"titles\":[\"JQ Primer\", \"More JQ\"]}",
              "output": [
                "{\"stedolan\": [\"JQ Primer\", \"More JQ\"]}"
              ]
            }
          ]
        },
        {
          "title": "Recursive Descent: `..`",
          "body": "\nRecursively descends `.`, producing every value.  This is the\nsame as the zero-argument `recurse` builtin (see below).  This\nis intended to resemble the XPath `//` operator.  Note that\n`..a` does not work; use `..|.a` instead.  In the example\nbelow we use `..|.a?` to find all the values of object keys\n\"a\" in any object found \"below\" `.`.\n\nThis is particularly useful in conjunction with `path(EXP)`\n(also see below) and the `?` operator.\n",
          "examples": [
            {
              "program": "..|.a?",
              "input": "[[{\"a\":1}]]",
              "output": [
                "1"
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "Builtin operators and functions",
      "body": "\nSome jq operators (for instance, `+`) do different things\ndepending on the type of their arguments (arrays, numbers,\netc.). However, jq never does implicit type conversions. If you\ntry to add a string to an object you'll get an error message and\nno result.\n",
      "entries": [
        {
          "title": "Addition: `+`",
          "body": "\nThe operator `+` takes two filters, applies them both\nto the same input, and adds the results together. What\n\"adding\" means depends on the types involved:\n\n- **Numbers** are added by normal arithmetic.\n\n- **Arrays** are added by being concatenated into a larger array.\n\n- **Strings** are added by being joined into a larger string.\n\n- **Objects** are added by merging, that is, inserting all\n    the key-value pairs from both objects into a single\n    combined object. If both objects contain a value for the\n    same key, the object on the right of the `+` wins. (For\n    recursive merge use the `*` operator.)\n\n`null` can be added to any value, and returns the other\nvalue unchanged.\n",
          "examples": [
            {
              "program": ".a + 1",
              "input": "{\"a\": 7}",
              "output": [
                "8"
              ]
            },
            {
              "program": ".a + .b",
              "input": "{\"a\": [1,2], \"b\": [3,4]}",
              "output": [
                "[1,2,3,4]"
              ]
            },
            {
              "program": ".a + null",
              "input": "{\"a\": 1}",
              "output": [
                "1"
              ]
            },
            {
              "program": ".a + 1",
              "input": "{}",
              "output": [
                "1"
              ]
            },
            {
              "program": "{a: 1} + {b: 2} + {c: 3} + {a: 42}",
              "input": "null",
              "output": [
                "{\"a\": 42, \"b\": 2, \"c\": 3}"
              ]
            }
          ]
        },
        {
          "title": "Subtraction: `-`",
          "body": "\nAs well as normal arithmetic subtraction on numbers, the `-`\noperator can be used on arrays to remove all occurrences of\nthe second array's elements from the first array.\n",
          "examples": [
            {
              "program": "4 - .a",
              "input": "{\"a\":3}",
              "output": [
                "1"
              ]
            },
            {
              "program": ". - [\"xml\", \"yaml\"]",
              "input": "[\"xml\", \"yaml\", \"json\"]",
              "output": [
                "[\"json\"]"
              ]
            }
          ]
        },
        {
          "title": "Multiplication, division, modulo: `*`, `/`, and `%`",
          "body": "\nThese infix operators behave as expected when given two numbers.\nDivision by zero raises an error. `x % y` computes x modulo y.\n\nMultiplying a string by a number produces the concatenation of\nthat string that many times. `\"x\" * 0` produces **null**.\n\nDividing a string by another splits the first using the second\nas separators.\n\nMultiplying two objects will merge them recursively: this works\nlike addition but if both objects contain a value for the\nsame key, and the values are objects, the two are merged with\nthe same strategy.\n",
          "examples": [
            {
              "program": "10 / . * 3",
              "input": 5,
              "output": [
                6
              ]
            },
            {
              "program": ". / \", \"",
              "input": "\"a, b,c,d, e\"",
              "output": [
                "[\"a\",\"b,c,d\",\"e\"]"
              ]
            },
            {
              "program": "{\"k\": {\"a\": 1, \"b\": 2}} * {\"k\": {\"a\": 0,\"c\": 3}}",
              "input": "null",
              "output": [
                "{\"k\": {\"a\": 0, \"b\": 2, \"c\": 3}}"
              ]
            },
            {
              "program": ".[] | (1 / .)?",
              "input": "[1,0,-1]",
              "output": [
                "1",
                "-1"
              ]
            }
          ]
        },
        {
          "title": "`length`",
          "body": "\nThe builtin function `length` gets the length of various\ndifferent types of value:\n\n- The length of a **string** is the number of Unicode\n  codepoints it contains (which will be the same as its\n  JSON-encoded length in bytes if it's pure ASCII).\n\n- The length of an **array** is the number of elements.\n\n- The length of an **object** is the number of key-value pairs.\n\n- The length of **null** is zero.\n",
          "examples": [
            {
              "program": ".[] | length",
              "input": "[[1,2], \"string\", {\"a\":2}, null]",
              "output": [
                2,
                6,
                1,
                0
              ]
            }
          ]
        },
        {
          "title": "`utf8bytelength`",
          "body": "\nThe builtin function `utf8bytelength` outputs the number of\nbytes used to encode a string in UTF-8.\n",
          "examples": [
            {
              "program": "utf8bytelength",
              "input": "\"\\u03bc\"",
              "output": [
                2
              ]
            }
          ]
        },
        {
          "title": "`keys`, `keys_unsorted`",
          "body": "\nThe builtin function `keys`, when given an object, returns\nits keys in an array.\n\nThe keys are sorted \"alphabetically\", by unicode codepoint\norder. This is not an order that makes particular sense in\nany particular language, but you can count on it being the\nsame for any two objects with the same set of keys,\nregardless of locale settings.\n\nWhen `keys` is given an array, it returns the valid indices\nfor that array: the integers from 0 to length-1.\n\nThe `keys_unsorted` function is just like `keys`, but if\nthe input is an object then the keys will not be sorted,\ninstead the keys will roughly be in insertion order.\n",
          "examples": [
            {
              "program": "keys",
              "input": "{\"abc\": 1, \"abcd\": 2, \"Foo\": 3}",
              "output": [
                "[\"Foo\", \"abc\", \"abcd\"]"
              ]
            },
            {
              "program": "keys",
              "input": "[42,3,35]",
              "output": [
                "[0,1,2]"
              ]
            }
          ]
        },
        {
          "title": "`has(key)`",
          "body": "\nThe builtin function `has` returns whether the input object\nhas the given key, or the input array has an element at the\ngiven index.\n\n`has($key)` has the same effect as checking whether `$key`\nis a member of the array returned by `keys`, although `has`\nwill be faster.\n",
          "examples": [
            {
              "program": "map(has(\"foo\"))",
              "input": "[{\"foo\": 42}, {}]",
              "output": [
                "[true, false]"
              ]
            },
            {
              "program": "map(has(2))",
              "input": "[[0,1], [\"a\",\"b\",\"c\"]]",
              "output": [
                "[false, true]"
              ]
            }
          ]
        },
        {
          "title": "`in`",
          "body": "\nThe builtin function `in` returns whether or not the input key is in the\ngiven object, or the input index corresponds to an element\nin the given array. It is, essentially, an inversed version\nof `has`.\n",
          "examples": [
            {
              "program": ".[] | in({\"foo\": 42})",
              "input": "[\"foo\", \"bar\"]",
              "output": [
                "true",
                "false"
              ]
            },
            {
              "program": "map(in([0,1]))",
              "input": "[2, 0]",
              "output": [
                "[false, true]"
              ]
            }
          ]
        },
        {
          "title": "`map(x)`, `map_values(x)`",
          "body": "\nFor any filter `x`, `map(x)` will run that filter for each\nelement of the input array, and return the outputs in a new\narray. `map(.+1)` will increment each element of an array of numbers.\n\nSimilarly, `map_values(x)` will run that filter for each element,\nbut it will return an object when an object is passed.\n\n`map(x)` is equivalent to `[.[] | x]`. In fact, this is how\nit's defined. Similarly, `map_values(x)` is defined as `.[] |= x`.\n",
          "examples": [
            {
              "program": "map(.+1)",
              "input": "[1,2,3]",
              "output": [
                "[2,3,4]"
              ]
            },
            {
              "program": "map_values(.+1)",
              "input": "{\"a\": 1, \"b\": 2, \"c\": 3}",
              "output": [
                "{\"a\": 2, \"b\": 3, \"c\": 4}"
              ]
            }
          ]
        },
        {
          "title": "`path(path_expression)`",
          "body": "\nOutputs array representations of the given path expression\nin `.`.  The outputs are arrays of strings (object keys)\nand/or numbers (array indices).\n\nPath expressions are jq expressions like `.a`, but also `.[]`.\nThere are two types of path expressions: ones that can match\nexactly, and ones that cannot.  For example, `.a.b.c` is an\nexact match path expression, while `.a[].b` is not.\n\n`path(exact_path_expression)` will produce the array\nrepresentation of the path expression even if it does not\nexist in `.`, if `.` is `null` or an array or an object.\n\n`path(pattern)` will produce array representations of the\npaths matching `pattern` if the paths exist in `.`.\n\nNote that the path expressions are not different from normal\nexpressions.  The expression\n`path(..|select(type==\"boolean\"))` outputs all the paths to\nboolean values in `.`, and only those paths.\n",
          "examples": [
            {
              "program": "path(.a[0].b)",
              "input": "null",
              "output": [
                "[\"a\",0,\"b\"]"
              ]
            },
            {
              "program": "[path(..)]",
              "input": "{\"a\":[{\"b\":1}]}",
              "output": [
                "[[],[\"a\"],[\"a\",0],[\"a\",0,\"b\"]]"
              ]
            }
          ]
        },
        {
          "title": "`del(path_expression)`",
          "body": "\nThe builtin function `del` removes a key and its corresponding\nvalue from an object.\n",
          "examples": [
            {
              "program": "del(.foo)",
              "input": "{\"foo\": 42, \"bar\": 9001, \"baz\": 42}",
              "output": [
                "{\"bar\": 9001, \"baz\": 42}"
              ]
            },
            {
              "program": "del(.[1, 2])",
              "input": "[\"foo\", \"bar\", \"baz\"]",
              "output": [
                "[\"foo\"]"
              ]
            }
          ]
        },
        {
          "title": "`getpath(PATHS)`",
          "body": "\nThe builtin function `getpath` outputs the values in `.` found\nat each path in `PATHS`.\n",
          "examples": [
            {
              "program": "getpath([\"a\",\"b\"])",
              "input": "null",
              "output": [
                "null"
              ]
            },
            {
              "program": "[getpath([\"a\",\"b\"], [\"a\",\"c\"])]",
              "input": "{\"a\":{\"b\":0, \"c\":1}}",
              "output": [
                "[0, 1]"
              ]
            }
          ]
        },
        {
          "title": "`setpath(PATHS; VALUE)`",
          "body": "\nThe builtin function `setpath` sets the `PATHS` in `.` to `VALUE`.\n",
          "examples": [
            {
              "program": "setpath([\"a\",\"b\"]; 1)",
              "input": "null",
              "output": [
                "{\"a\": {\"b\": 1}}"
              ]
            },
            {
              "program": "setpath([\"a\",\"b\"]; 1)",
              "input": "{\"a\":{\"b\":0}}",
              "output": [
                "{\"a\": {\"b\": 1}}"
              ]
            },
            {
              "program": "setpath([0,\"a\"]; 1)",
              "input": "null",
              "output": [
                "[{\"a\":1}]"
              ]
            }
          ]
        },
        {
          "title": "`delpaths(PATHS)`",
          "body": "\nThe builtin function `delpaths` sets the `PATHS` in `.`.\n`PATHS` must be an array of paths, where each path is an array\nof strings and numbers.\n",
          "examples": [
            {
              "program": "delpaths([[\"a\",\"b\"]])",
              "input": "{\"a\":{\"b\":1},\"x\":{\"y\":2}}",
              "output": [
                "{\"a\":{},\"x\":{\"y\":2}}"
              ]
            }
          ]
        },
        {
          "title": "`to_entries`, `from_entries`, `with_entries`",
          "body": "\nThese functions convert between an object and an array of\nkey-value pairs. If `to_entries` is passed an object, then\nfor each `k: v` entry in the input, the output array\nincludes `{\"key\": k, \"value\": v}`.\n\n`from_entries` does the opposite conversion, and\n`with_entries(foo)` is a shorthand for `to_entries |\nmap(foo) | from_entries`, useful for doing some operation to\nall keys and values of an object. `from_entries` accepts key, Key,\nname, Name, value and Value as keys.\n",
          "examples": [
            {
              "program": "to_entries",
              "input": "{\"a\": 1, \"b\": 2}",
              "output": [
                "[{\"key\":\"a\", \"value\":1}, {\"key\":\"b\", \"value\":2}]"
              ]
            },
            {
              "program": "from_entries",
              "input": "[{\"key\":\"a\", \"value\":1}, {\"key\":\"b\", \"value\":2}]",
              "output": [
                "{\"a\": 1, \"b\": 2}"
              ]
            },
            {
              "program": "with_entries(.key |= \"KEY_\" + .)",
              "input": "{\"a\": 1, \"b\": 2}",
              "output": [
                "{\"KEY_a\": 1, \"KEY_b\": 2}"
              ]
            }
          ]
        },
        {
          "title": "`select(boolean_expression)`",
          "body": "\nThe function `select(foo)` produces its input unchanged if\n`foo` returns true for that input, and produces no output\notherwise.\n\nIt's useful for filtering lists: `[1,2,3] | map(select(. >= 2))`\nwill give you `[2,3]`.\n",
          "examples": [
            {
              "program": "map(select(. >= 2))",
              "input": "[1,5,3,0,7]",
              "output": [
                "[5,3,7]"
              ]
            },
            {
              "program": ".[] | select(.id == \"second\")",
              "input": "[{\"id\": \"first\", \"val\": 1}, {\"id\": \"second\", \"val\": 2}]",
              "output": [
                "{\"id\": \"second\", \"val\": 2}"
              ]
            }
          ]
        },
        {
          "title": "`arrays`, `objects`, `iterables`, `booleans`, `numbers`, `normals`, `finites`, `strings`, `nulls`, `values`, `scalars`",
          "body": "\nThese built-ins select only inputs that are arrays, objects,\niterables (arrays or objects), booleans, numbers, normal\nnumbers, finite numbers, strings, null, non-null values, and\nnon-iterables, respectively.\n",
          "examples": [
            {
              "program": ".[]|numbers",
              "input": "[[],{},1,\"foo\",null,true,false]",
              "output": [
                "1"
              ]
            }
          ]
        },
        {
          "title": "`empty`",
          "body": "\n`empty` returns no results. None at all. Not even `null`.\n\nIt's useful on occasion. You'll know if you need it :)\n",
          "examples": [
            {
              "program": "1, empty, 2",
              "input": "null",
              "output": [
                1,
                2
              ]
            },
            {
              "program": "[1,2,empty,3]",
              "input": "null",
              "output": [
                "[1,2,3]"
              ]
            }
          ]
        },
        {
          "title": "`error(message)`",
          "body": "\nProduces an error, just like `.a` applied to values other than\nnull and objects would, but with the given message as the\nerror's value.  Errors can be caught with try/catch; see below.\n"
        },
        {
          "title": "`halt`",
          "body": "\nStops the jq program with no further outputs.  jq will exit\nwith exit status `0`.\n"
        },
        {
          "title": "`halt_error`, `halt_error(exit_code)`",
          "body": "\nStops the jq program with no further outputs.  The input will\nbe printed on `stderr` as raw output (i.e., strings will not\nhave double quotes) with no decoration, not even a newline.\n\nThe given `exit_code` (defaulting to `5`) will be jq's exit\nstatus.\n\nFor example, `\"Error: somthing went wrong\\n\"|halt_error(1)`.\n"
        },
        {
          "title": "`$__loc__`",
          "body": "\nProduces an object with a \"file\" key and a \"line\" key, with\nthe filename and line number where `$__loc__` occurs, as\nvalues.\n",
          "examples": [
            {
              "program": "try error(\"\\($__loc__)\") catch .",
              "input": "null",
              "output": [
                "\"{\\\"file\\\":\\\"<top-level>\\\",\\\"line\\\":1}\""
              ]
            }
          ]
        },
        {
          "title": "`paths`, `paths(node_filter)`, `leaf_paths`",
          "body": "\n`paths` outputs the paths to all the elements in its input\n(except it does not output the empty list, representing .\nitself).\n\n`paths(f)` outputs the paths to any values for which `f` is true.\nThat is, `paths(numbers)` outputs the paths to all numeric\nvalues.\n\n`leaf_paths` is an alias of `paths(scalars)`; `leaf_paths` is\n*deprecated* and will be removed in the next major release.\n",
          "examples": [
            {
              "program": "[paths]",
              "input": "[1,[[],{\"a\":2}]]",
              "output": [
                "[[0],[1],[1,0],[1,1],[1,1,\"a\"]]"
              ]
            },
            {
              "program": "[paths(scalars)]",
              "input": "[1,[[],{\"a\":2}]]",
              "output": [
                "[[0],[1,1,\"a\"]]"
              ]
            }
          ]
        },
        {
          "title": "`add`",
          "body": "\nThe filter `add` takes as input an array, and produces as\noutput the elements of the array added together. This might\nmean summed, concatenated or merged depending on the types\nof the elements of the input array - the rules are the same\nas those for the `+` operator (described above).\n\nIf the input is an empty array, `add` returns `null`.\n",
          "examples": [
            {
              "program": "add",
              "input": "[\"a\",\"b\",\"c\"]",
              "output": [
                "\"abc\""
              ]
            },
            {
              "program": "add",
              "input": "[1, 2, 3]",
              "output": [
                6
              ]
            },
            {
              "program": "add",
              "input": "[]",
              "output": [
                "null"
              ]
            }
          ]
        },
        {
          "title": "`any`, `any(condition)`, `any(generator; condition)`",
          "body": "\nThe filter `any` takes as input an array of boolean values,\nand produces `true` as output if any of the elements of\nthe array are `true`.\n\nIf the input is an empty array, `any` returns `false`.\n\nThe `any(condition)` form applies the given condition to the\nelements of the input array.\n\nThe `any(generator; condition)` form applies the given\ncondition to all the outputs of the given generator.\n",
          "examples": [
            {
              "program": "any",
              "input": "[true, false]",
              "output": [
                "true"
              ]
            },
            {
              "program": "any",
              "input": "[false, false]",
              "output": [
                "false"
              ]
            },
            {
              "program": "any",
              "input": "[]",
              "output": [
                "false"
              ]
            }
          ]
        },
        {
          "title": "`all`, `all(condition)`, `all(generator; condition)`",
          "body": "\nThe filter `all` takes as input an array of boolean values,\nand produces `true` as output if all of the elements of\nthe array are `true`.\n\nThe `all(condition)` form applies the given condition to the\nelements of the input array.\n\nThe `all(generator; condition)` form applies the given\ncondition to all the outputs of the given generator.\n\nIf the input is an empty array, `all` returns `true`.\n",
          "examples": [
            {
              "program": "all",
              "input": "[true, false]",
              "output": [
                "false"
              ]
            },
            {
              "program": "all",
              "input": "[true, true]",
              "output": [
                "true"
              ]
            },
            {
              "program": "all",
              "input": "[]",
              "output": [
                "true"
              ]
            }
          ]
        },
        {
          "title": "`flatten`, `flatten(depth)`",
          "body": "\nThe filter `flatten` takes as input an array of nested arrays,\nand produces a flat array in which all arrays inside the original\narray have been recursively replaced by their values. You can pass\nan argument to it to specify how many levels of nesting to flatten.\n\n`flatten(2)` is like `flatten`, but going only up to two\nlevels deep.\n",
          "examples": [
            {
              "program": "flatten",
              "input": "[1, [2], [[3]]]",
              "output": [
                "[1, 2, 3]"
              ]
            },
            {
              "program": "flatten(1)",
              "input": "[1, [2], [[3]]]",
              "output": [
                "[1, 2, [3]]"
              ]
            },
            {
              "program": "flatten",
              "input": "[[]]",
              "output": [
                "[]"
              ]
            },
            {
              "program": "flatten",
              "input": "[{\"foo\": \"bar\"}, [{\"foo\": \"baz\"}]]",
              "output": [
                "[{\"foo\": \"bar\"}, {\"foo\": \"baz\"}]"
              ]
            }
          ]
        },
        {
          "title": "`range(upto)`, `range(from;upto)` `range(from;upto;by)`",
          "body": "\nThe `range` function produces a range of numbers. `range(4;10)`\nproduces 6 numbers, from 4 (inclusive) to 10 (exclusive). The numbers\nare produced as separate outputs. Use `[range(4;10)]` to get a range as\nan array.\n\nThe one argument form generates numbers from 0 to the given\nnumber, with an increment of 1.\n\nThe two argument form generates numbers from `from` to `upto`\nwith an increment of 1.\n\nThe three argument form generates numbers `from` to `upto`\nwith an increment of `by`.\n",
          "examples": [
            {
              "program": "range(2;4)",
              "input": "null",
              "output": [
                "2",
                "3"
              ]
            },
            {
              "program": "[range(2;4)]",
              "input": "null",
              "output": [
                "[2,3]"
              ]
            },
            {
              "program": "[range(4)]",
              "input": "null",
              "output": [
                "[0,1,2,3]"
              ]
            },
            {
              "program": "[range(0;10;3)]",
              "input": "null",
              "output": [
                "[0,3,6,9]"
              ]
            },
            {
              "program": "[range(0;10;-1)]",
              "input": "null",
              "output": [
                "[]"
              ]
            },
            {
              "program": "[range(0;-5;-1)]",
              "input": "null",
              "output": [
                "[0,-1,-2,-3,-4]"
              ]
            }
          ]
        },
        {
          "title": "`floor`",
          "body": "\nThe `floor` function returns the floor of its numeric input.\n",
          "examples": [
            {
              "program": "floor",
              "input": "3.14159",
              "output": [
                "3"
              ]
            }
          ]
        },
        {
          "title": "`sqrt`",
          "body": "\nThe `sqrt` function returns the square root of its numeric input.\n",
          "examples": [
            {
              "program": "sqrt",
              "input": "9",
              "output": [
                "3"
              ]
            }
          ]
        },
        {
          "title": "`tonumber`",
          "body": "\nThe `tonumber` function parses its input as a number. It\nwill convert correctly-formatted strings to their numeric\nequivalent, leave numbers alone, and give an error on all other input.\n",
          "examples": [
            {
              "program": ".[] | tonumber",
              "input": "[1, \"1\"]",
              "output": [
                1,
                1
              ]
            }
          ]
        },
        {
          "title": "`tostring`",
          "body": "\nThe `tostring` function prints its input as a\nstring. Strings are left unchanged, and all other values are\nJSON-encoded.\n",
          "examples": [
            {
              "program": ".[] | tostring",
              "input": "[1, \"1\", [1]]",
              "output": [
                "\"1\"",
                "\"1\"",
                "\"[1]\""
              ]
            }
          ]
        },
        {
          "title": "`type`",
          "body": "\nThe `type` function returns the type of its argument as a\nstring, which is one of null, boolean, number, string, array\nor object.\n",
          "examples": [
            {
              "program": "map(type)",
              "input": "[0, false, [], {}, null, \"hello\"]",
              "output": [
                "[\"number\", \"boolean\", \"array\", \"object\", \"null\", \"string\"]"
              ]
            }
          ]
        },
        {
          "title": "`infinite`, `nan`, `isinfinite`, `isnan`, `isfinite`, `isnormal`",
          "body": "\nSome arithmetic operations can yield infinities and \"not a\nnumber\" (NaN) values.  The `isinfinite` builtin returns `true`\nif its input is infinite.  The `isnan` builtin returns `true`\nif its input is a NaN.  The `infinite` builtin returns a\npositive infinite value.  The `nan` builtin returns a NaN.\nThe `isnormal` builtin returns true if its input is a normal\nnumber.\n\nNote that division by zero raises an error.\n\nCurrently most arithmetic operations operating on infinities,\nNaNs, and sub-normals do not raise errors.\n",
          "examples": [
            {
              "program": ".[] | (infinite * .) < 0",
              "input": "[-1, 1]",
              "output": [
                "true",
                "false"
              ]
            },
            {
              "program": "infinite, nan | type",
              "input": "null",
              "output": [
                "\"number\"",
                "\"number\""
              ]
            }
          ]
        },
        {
          "title": "`sort, sort_by(path_expression)`",
          "body": "\nThe `sort` functions sorts its input, which must be an\narray. Values are sorted in the following order:\n\n* `null`\n* `false`\n* `true`\n* numbers\n* strings, in alphabetical order (by unicode codepoint value)\n* arrays, in lexical order\n* objects\n\nThe ordering for objects is a little complex: first they're\ncompared by comparing their sets of keys (as arrays in\nsorted order), and if their keys are equal then the values\nare compared key by key.\n\n`sort` may be used to sort by a particular field of an\nobject, or by applying any jq filter.\n\n`sort_by(foo)` compares two elements by comparing the result of\n`foo` on each element.\n",
          "examples": [
            {
              "program": "sort",
              "input": "[8,3,null,6]",
              "output": [
                "[null,3,6,8]"
              ]
            },
            {
              "program": "sort_by(.foo)",
              "input": "[{\"foo\":4, \"bar\":10}, {\"foo\":3, \"bar\":100}, {\"foo\":2, \"bar\":1}]",
              "output": [
                "[{\"foo\":2, \"bar\":1}, {\"foo\":3, \"bar\":100}, {\"foo\":4, \"bar\":10}]"
              ]
            }
          ]
        },
        {
          "title": "`group_by(path_expression)`",
          "body": "\n`group_by(.foo)` takes as input an array, groups the\nelements having the same `.foo` field into separate arrays,\nand produces all of these arrays as elements of a larger\narray, sorted by the value of the `.foo` field.\n\nAny jq expression, not just a field access, may be used in\nplace of `.foo`. The sorting order is the same as described\nin the `sort` function above.\n",
          "examples": [
            {
              "program": "group_by(.foo)",
              "input": "[{\"foo\":1, \"bar\":10}, {\"foo\":3, \"bar\":100}, {\"foo\":1, \"bar\":1}]",
              "output": [
                "[[{\"foo\":1, \"bar\":10}, {\"foo\":1, \"bar\":1}], [{\"foo\":3, \"bar\":100}]]"
              ]
            }
          ]
        },
        {
          "title": "`min`, `max`, `min_by(path_exp)`, `max_by(path_exp)`",
          "body": "\nFind the minimum or maximum element of the input array.\n\nThe `min_by(path_exp)` and `max_by(path_exp)` functions allow\nyou to specify a particular field or property to examine, e.g.\n`min_by(.foo)` finds the object with the smallest `foo` field.\n",
          "examples": [
            {
              "program": "min",
              "input": "[5,4,2,7]",
              "output": [
                "2"
              ]
            },
            {
              "program": "max_by(.foo)",
              "input": "[{\"foo\":1, \"bar\":14}, {\"foo\":2, \"bar\":3}]",
              "output": [
                "{\"foo\":2, \"bar\":3}"
              ]
            }
          ]
        },
        {
          "title": "`unique`, `unique_by(path_exp)`",
          "body": "\nThe `unique` function takes as input an array and produces\nan array of the same elements, in sorted order, with\nduplicates removed.\n\nThe `unique_by(path_exp)` function will keep only one element\nfor each value obtained by applying the argument. Think of it\nas making an array by taking one element out of every group\nproduced by `group`.\n",
          "examples": [
            {
              "program": "unique",
              "input": "[1,2,5,3,5,3,1,3]",
              "output": [
                "[1,2,3,5]"
              ]
            },
            {
              "program": "unique_by(.foo)",
              "input": "[{\"foo\": 1, \"bar\": 2}, {\"foo\": 1, \"bar\": 3}, {\"foo\": 4, \"bar\": 5}]",
              "output": [
                "[{\"foo\": 1, \"bar\": 2}, {\"foo\": 4, \"bar\": 5}]"
              ]
            },
            {
              "program": "unique_by(length)",
              "input": "[\"chunky\", \"bacon\", \"kitten\", \"cicada\", \"asparagus\"]",
              "output": [
                "[\"bacon\", \"chunky\", \"asparagus\"]"
              ]
            }
          ]
        },
        {
          "title": "`reverse`",
          "body": "\nThis function reverses an array.\n",
          "examples": [
            {
              "program": "reverse",
              "input": "[1,2,3,4]",
              "output": [
                "[4,3,2,1]"
              ]
            }
          ]
        },
        {
          "title": "`contains(element)`",
          "body": "\nThe filter `contains(b)` will produce true if b is\ncompletely contained within the input. A string B is\ncontained in a string A if B is a substring of A. An array B\nis contained in an array A if all elements in B are\ncontained in any element in A. An object B is contained in\nobject A if all of the values in B are contained in the\nvalue in A with the same key. All other types are assumed to\nbe contained in each other if they are equal.\n",
          "examples": [
            {
              "program": "contains(\"bar\")",
              "input": "\"foobar\"",
              "output": [
                "true"
              ]
            },
            {
              "program": "contains([\"baz\", \"bar\"])",
              "input": "[\"foobar\", \"foobaz\", \"blarp\"]",
              "output": [
                "true"
              ]
            },
            {
              "program": "contains([\"bazzzzz\", \"bar\"])",
              "input": "[\"foobar\", \"foobaz\", \"blarp\"]",
              "output": [
                "false"
              ]
            },
            {
              "program": "contains({foo: 12, bar: [{barp: 12}]})",
              "input": "{\"foo\": 12, \"bar\":[1,2,{\"barp\":12, \"blip\":13}]}",
              "output": [
                "true"
              ]
            },
            {
              "program": "contains({foo: 12, bar: [{barp: 15}]})",
              "input": "{\"foo\": 12, \"bar\":[1,2,{\"barp\":12, \"blip\":13}]}",
              "output": [
                "false"
              ]
            }
          ]
        },
        {
          "title": "`indices(s)`",
          "body": "\nOutputs an array containing the indices in `.` where `s`\noccurs.  The input may be an array, in which case if `s` is an\narray then the indices output will be those where all elements\nin `.` match those of `s`.\n",
          "examples": [
            {
              "program": "indices(\", \")",
              "input": "\"a,b, cd, efg, hijk\"",
              "output": [
                "[3,7,12]"
              ]
            },
            {
              "program": "indices(1)",
              "input": "[0,1,2,1,3,1,4]",
              "output": [
                "[1,3,5]"
              ]
            },
            {
              "program": "indices([1,2])",
              "input": "[0,1,2,3,1,4,2,5,1,2,6,7]",
              "output": [
                "[1,8]"
              ]
            }
          ]
        },
        {
          "title": "`index(s)`, `rindex(s)`",
          "body": "\nOutputs the index of the first (`index`) or last (`rindex`)\noccurrence of `s` in the input.\n",
          "examples": [
            {
              "program": "index(\", \")",
              "input": "\"a,b, cd, efg, hijk\"",
              "output": [
                "3"
              ]
            },
            {
              "program": "rindex(\", \")",
              "input": "\"a,b, cd, efg, hijk\"",
              "output": [
                "12"
              ]
            }
          ]
        },
        {
          "title": "`inside`",
          "body": "\nThe filter `inside(b)` will produce true if the input is\ncompletely contained within b. It is, essentially, an\ninversed version of `contains`.\n",
          "examples": [
            {
              "program": "inside(\"foobar\")",
              "input": "\"bar\"",
              "output": [
                "true"
              ]
            },
            {
              "program": "inside([\"foobar\", \"foobaz\", \"blarp\"])",
              "input": "[\"baz\", \"bar\"]",
              "output": [
                "true"
              ]
            },
            {
              "program": "inside([\"foobar\", \"foobaz\", \"blarp\"])",
              "input": "[\"bazzzzz\", \"bar\"]",
              "output": [
                "false"
              ]
            },
            {
              "program": "inside({\"foo\": 12, \"bar\":[1,2,{\"barp\":12, \"blip\":13}]})",
              "input": "{\"foo\": 12, \"bar\": [{\"barp\": 12}]}",
              "output": [
                "true"
              ]
            },
            {
              "program": "inside({\"foo\": 12, \"bar\":[1,2,{\"barp\":12, \"blip\":13}]})",
              "input": "{\"foo\": 12, \"bar\": [{\"barp\": 15}]}",
              "output": [
                "false"
              ]
            }
          ]
        },
        {
          "title": "`startswith(str)`",
          "body": "\nOutputs `true` if . starts with the given string argument.\n",
          "examples": [
            {
              "program": "[.[]|startswith(\"foo\")]",
              "input": "[\"fo\", \"foo\", \"barfoo\", \"foobar\", \"barfoob\"]",
              "output": [
                "[false, true, false, true, false]"
              ]
            }
          ]
        },
        {
          "title": "`endswith(str)`",
          "body": "\nOutputs `true` if . ends with the given string argument.\n",
          "examples": [
            {
              "program": "[.[]|endswith(\"foo\")]",
              "input": "[\"foobar\", \"barfoo\"]",
              "output": [
                "[false, true]"
              ]
            }
          ]
        },
        {
          "title": "`combinations`, `combinations(n)`",
          "body": "\nOutputs all combinations of the elements of the arrays in the\ninput array. If given an argument `n`, it outputs all combinations\nof `n` repetitions of the input array.\n",
          "examples": [
            {
              "program": "combinations",
              "input": "[[1,2], [3, 4]]",
              "output": [
                "[1, 3]",
                "[1, 4]",
                "[2, 3]",
                "[2, 4]"
              ]
            },
            {
              "program": "combinations(2)",
              "input": "[0, 1]",
              "output": [
                "[0, 0]",
                "[0, 1]",
                "[1, 0]",
                "[1, 1]"
              ]
            }
          ]
        },
        {
          "title": "`ltrimstr(str)`",
          "body": "\nOutputs its input with the given prefix string removed, if it\nstarts with it.\n",
          "examples": [
            {
              "program": "[.[]|ltrimstr(\"foo\")]",
              "input": "[\"fo\", \"foo\", \"barfoo\", \"foobar\", \"afoo\"]",
              "output": [
                "[\"fo\",\"\",\"barfoo\",\"bar\",\"afoo\"]"
              ]
            }
          ]
        },
        {
          "title": "`rtrimstr(str)`",
          "body": "\nOutputs its input with the given suffix string removed, if it\nends with it.\n",
          "examples": [
            {
              "program": "[.[]|rtrimstr(\"foo\")]",
              "input": "[\"fo\", \"foo\", \"barfoo\", \"foobar\", \"foob\"]",
              "output": [
                "[\"fo\",\"\",\"bar\",\"foobar\",\"foob\"]"
              ]
            }
          ]
        },
        {
          "title": "`explode`",
          "body": "\nConverts an input string into an array of the string's\ncodepoint numbers.\n",
          "examples": [
            {
              "program": "explode",
              "input": "\"foobar\"",
              "output": [
                "[102,111,111,98,97,114]"
              ]
            }
          ]
        },
        {
          "title": "`implode`",
          "body": "\nThe inverse of explode.\n",
          "examples": [
            {
              "program": "implode",
              "input": "[65, 66, 67]",
              "output": [
                "\"ABC\""
              ]
            }
          ]
        },
        {
          "title": "`split(str)`",
          "body": "\nSplits an input string on the separator argument.\n",
          "examples": [
            {
              "program": "split(\", \")",
              "input": "\"a, b,c,d, e, \"",
              "output": [
                "[\"a\",\"b,c,d\",\"e\",\"\"]"
              ]
            }
          ]
        },
        {
          "title": "`join(str)`",
          "body": "\nJoins the array of elements given as input, using the\nargument as separator. It is the inverse of `split`: that is,\nrunning `split(\"foo\") | join(\"foo\")` over any input string\nreturns said input string.\n\nNumbers and booleans in the input are converted to strings.\nNull values are treated as empty strings. Arrays and objects\nin the input are not supported.\n",
          "examples": [
            {
              "program": "join(\", \")",
              "input": "[\"a\",\"b,c,d\",\"e\"]",
              "output": [
                "\"a, b,c,d, e\""
              ]
            },
            {
              "program": "join(\" \")",
              "input": "[\"a\",1,2.3,true,null,false]",
              "output": [
                "\"a 1 2.3 true  false\""
              ]
            }
          ]
        },
        {
          "title": "`ascii_downcase`, `ascii_upcase`",
          "body": "\nEmit a copy of the input string with its alphabetic characters (a-z and A-Z)\nconverted to the specified case.\n",
          "example": [
            {
              "program": "ascii_upcase",
              "input": "\"useful but not for \"",
              "output": "\"USEFUL BUT NOT FOR \""
            }
          ]
        },
        {
          "title": "`while(cond; update)`",
          "body": "\nThe `while(cond; update)` function allows you to repeatedly\napply an update to `.` until `cond` is false.\n\nNote that `while(cond; update)` is internally defined as a\nrecursive jq function.  Recursive calls within `while` will\nnot consume additional memory if `update` produces at most one\noutput for each input.  See advanced topics below.\n",
          "examples": [
            {
              "program": "[while(.<100; .*2)]",
              "input": "1",
              "output": [
                "[1,2,4,8,16,32,64]"
              ]
            }
          ]
        },
        {
          "title": "`until(cond; next)`",
          "body": "\nThe `until(cond; next)` function allows you to repeatedly\napply the expression `next`, initially to `.` then to its own\noutput, until `cond` is true.  For example, this can be used\nto implement a factorial function (see below).\n\nNote that `until(cond; next)` is internally defined as a\nrecursive jq function.  Recursive calls within `until()` will\nnot consume additional memory if `next` produces at most one\noutput for each input.  See advanced topics below.\n",
          "examples": [
            {
              "program": "[.,1]|until(.[0] < 1; [.[0] - 1, .[1] * .[0]])|.[1]",
              "input": "4",
              "output": [
                "24"
              ]
            }
          ]
        },
        {
          "title": "`recurse(f)`, `recurse`, `recurse(f; condition)`, `recurse_down`",
          "body": "\nThe `recurse(f)` function allows you to search through a\nrecursive structure, and extract interesting data from all\nlevels. Suppose your input represents a filesystem:\n\n    {\"name\": \"/\", \"children\": [\n      {\"name\": \"/bin\", \"children\": [\n        {\"name\": \"/bin/ls\", \"children\": []},\n        {\"name\": \"/bin/sh\", \"children\": []}]},\n      {\"name\": \"/home\", \"children\": [\n        {\"name\": \"/home/stephen\", \"children\": [\n          {\"name\": \"/home/stephen/jq\", \"children\": []}]}]}]}\n\nNow suppose you want to extract all of the filenames\npresent. You need to retrieve `.name`, `.children[].name`,\n`.children[].children[].name`, and so on. You can do this\nwith:\n\n    recurse(.children[]) | .name\n\nWhen called without an argument, `recurse` is equivalent to\n`recurse(.[]?)`.\n\n`recurse(f)` is identical to `recurse(f; . != null)` and can be\nused without concerns about recursion depth.\n\n`recurse(f; condition)` is a generator which begins by\nemitting . and then emits in turn .|f, .|f|f, .|f|f|f, ...  so long\nas the computed value satisfies the condition. For example,\nto generate all the integers, at least in principle, one\ncould write `recurse(.+1; true)`.\n\nFor legacy reasons, `recurse_down` exists as an alias to\ncalling `recurse` without arguments. This alias is considered\n*deprecated* and will be removed in the next major release.\n\nThe recursive calls in `recurse` will not consume additional\nmemory whenever `f` produces at most a single output for each\ninput.\n",
          "examples": [
            {
              "program": "recurse(.foo[])",
              "input": "{\"foo\":[{\"foo\": []}, {\"foo\":[{\"foo\":[]}]}]}",
              "output": [
                "{\"foo\":[{\"foo\":[]},{\"foo\":[{\"foo\":[]}]}]}",
                "{\"foo\":[]}",
                "{\"foo\":[{\"foo\":[]}]}",
                "{\"foo\":[]}"
              ]
            },
            {
              "program": "recurse",
              "input": "{\"a\":0,\"b\":[1]}",
              "output": [
                "{\"a\":0,\"b\":[1]}",
                "0",
                "[1]",
                "1"
              ]
            },
            {
              "program": "recurse(. * .; . < 20)",
              "input": 2,
              "output": [
                2,
                4,
                16
              ]
            }
          ]
        },
        {
          "title": "`walk(f)`",
          "body": "\nThe `walk(f)` function applies f recursively to every\ncomponent of the input entity.  When an array is\nencountered, f is first applied to its elements and then to\nthe array itself; when an object is encountered, f is first\napplied to all the values and then to the object.  In\npractice, f will usually test the type of its input, as\nillustrated in the following examples.  The first example\nhighlights the usefulness of processing the elements of an\narray of arrays before processing the array itself.  The second\nexample shows how all the keys of all the objects within the\ninput can be considered for alteration.\n",
          "examples": [
            {
              "program": "walk(if type == \"array\" then sort else . end)",
              "input": "[[4, 1, 7], [8, 5, 2], [3, 6, 9]]",
              "output": [
                "[[1,4,7],[2,5,8],[3,6,9]]"
              ]
            },
            {
              "program": "walk( if type == \"object\" then with_entries( .key |= sub( \"^_+\"; \"\") ) else . end )",
              "input": "[ { \"_a\": { \"__b\": 2 } } ]",
              "output": [
                "[{\"a\":{\"b\":2}}]"
              ]
            }
          ]
        },
        {
          "title": "`$ENV`, `env`",
          "body": "\n`$ENV` is an object representing the environment variables as\nset when the jq program started.\n\n`env` outputs an object representing jq's current environment.\n\nAt the moment there is no builtin for setting environment\nvariables.\n",
          "examples": [
            {
              "program": "$ENV.PAGER",
              "input": "null",
              "output": [
                "\"less\""
              ]
            },
            {
              "program": "env.PAGER",
              "input": "null",
              "output": [
                "\"less\""
              ]
            }
          ]
        },
        {
          "title": "`transpose`",
          "body": "\nTranspose a possibly jagged matrix (an array of arrays).\nRows are padded with nulls so the result is always rectangular.\n",
          "examples": [
            {
              "program": "transpose",
              "input": "[[1], [2,3]]",
              "output": [
                "[[1,2],[null,3]]"
              ]
            }
          ]
        },
        {
          "title": "`bsearch(x)`",
          "body": "\nbsearch(x) conducts a binary search for x in the input\narray.  If the input is sorted and contains x, then\nbsearch(x) will return its index in the array; otherwise, if\nthe array is sorted, it will return (-1 - ix) where ix is an\ninsertion point such that the array would still be sorted\nafter the insertion of x at ix.  If the array is not sorted,\nbsearch(x) will return an integer that is probably of no\ninterest.\n",
          "examples": [
            {
              "program": "bsearch(0)",
              "input": "[0,1]",
              "output": [
                "0"
              ]
            },
            {
              "program": "bsearch(0)",
              "input": "[1,2,3]",
              "output": [
                "-1"
              ]
            },
            {
              "program": "bsearch(4) as $ix | if $ix < 0 then .[-(1+$ix)] = 4 else . end",
              "input": "[1,2,3]",
              "output": [
                "[1,2,3,4]"
              ]
            }
          ]
        },
        {
          "title": "String interpolation - `\\(foo)`",
          "body": "\nInside a string, you can put an expression inside parens\nafter a backslash. Whatever the expression returns will be\ninterpolated into the string.\n",
          "examples": [
            {
              "program": "\"The input was \\(.), which is one less than \\(.+1)\"",
              "input": "42",
              "output": [
                "\"The input was 42, which is one less than 43\""
              ]
            }
          ]
        },
        {
          "title": "Convert to/from JSON",
          "body": "\nThe `tojson` and `fromjson` builtins dump values as JSON texts\nor parse JSON texts into values, respectively.  The tojson\nbuiltin differs from tostring in that tostring returns strings\nunmodified, while tojson encodes strings as JSON strings.\n",
          "examples": [
            {
              "program": "[.[]|tostring]",
              "input": "[1, \"foo\", [\"foo\"]]",
              "output": [
                "[\"1\",\"foo\",\"[\\\"foo\\\"]\"]"
              ]
            },
            {
              "program": "[.[]|tojson]",
              "input": "[1, \"foo\", [\"foo\"]]",
              "output": [
                "[\"1\",\"\\\"foo\\\"\",\"[\\\"foo\\\"]\"]"
              ]
            },
            {
              "program": "[.[]|tojson|fromjson]",
              "input": "[1, \"foo\", [\"foo\"]]",
              "output": [
                "[1,\"foo\",[\"foo\"]]"
              ]
            }
          ]
        },
        {
          "title": "Format strings and escaping",
          "body": "\nThe `@foo` syntax is used to format and escape strings,\nwhich is useful for building URLs, documents in a language\nlike HTML or XML, and so forth. `@foo` can be used as a\nfilter on its own, the possible escapings are:\n\n* `@text`:\n\n  Calls `tostring`, see that function for details.\n\n* `@json`:\n\n  Serializes the input as JSON.\n\n* `@html`:\n\n  Applies HTML/XML escaping, by mapping the characters\n  `<>&'\"` to their entity equivalents `&lt;`, `&gt;`,\n  `&amp;`, `&apos;`, `&quot;`.\n\n* `@uri`:\n\n  Applies percent-encoding, by mapping all reserved URI\n  characters to a `%XX` sequence.\n\n* `@csv`:\n\n  The input must be an array, and it is rendered as CSV\n  with double quotes for strings, and quotes escaped by\n  repetition.\n\n* `@tsv`:\n\n  The input must be an array, and it is rendered as TSV\n  (tab-separated values). Each input array will be printed as\n  a single line. Fields are separated by a single\n  tab (ascii `0x09`). Input characters line-feed (ascii `0x0a`),\n  carriage-return (ascii `0x0d`), tab (ascii `0x09`) and\n  backslash (ascii `0x5c`) will be output as escape sequences\n  `\\n`, `\\r`, `\\t`, `\\\\` respectively.\n\n* `@sh`:\n\n  The input is escaped suitable for use in a command-line\n  for a POSIX shell. If the input is an array, the output\n  will be a series of space-separated strings.\n\n* `@base64`:\n\n  The input is converted to base64 as specified by RFC 4648.\n\n* `@base64d`:\n\n  The inverse of `@base64`, input is decoded as specified by RFC 4648.\n  Note\\: If the decoded string is not UTF-8, the results are undefined.\n\nThis syntax can be combined with string interpolation in a\nuseful way. You can follow a `@foo` token with a string\nliteral. The contents of the string literal will *not* be\nescaped. However, all interpolations made inside that string\nliteral will be escaped. For instance,\n\n    @uri \"https://www.google.com/search?q=\\(.search)\"\n\nwill produce the following output for the input\n`{\"search\":\"what is jq?\"}`:\n\n    \"https://www.google.com/search?q=what%20is%20jq%3F\"\n\nNote that the slashes, question mark, etc. in the URL are\nnot escaped, as they were part of the string literal.\n",
          "examples": [
            {
              "program": "@html",
              "input": "\"This works if x < y\"",
              "output": [
                "\"This works if x &lt; y\""
              ]
            },
            {
              "program": "@sh \"echo \\(.)\"",
              "input": "\"O'Hara's Ale\"",
              "output": [
                "\"echo 'O'\\\\''Hara'\\\\''s Ale'\""
              ]
            },
            {
              "program": "@base64",
              "input": "\"This is a message\"",
              "output": [
                "\"VGhpcyBpcyBhIG1lc3NhZ2U=\""
              ]
            },
            {
              "program": "@base64d",
              "input": "\"VGhpcyBpcyBhIG1lc3NhZ2U=\"",
              "output": [
                "\"This is a message\""
              ]
            }
          ]
        },
        {
          "title": "Dates",
          "body": "\njq provides some basic date handling functionality, with some\nhigh-level and low-level builtins.  In all cases these\nbuiltins deal exclusively with time in UTC.\n\nThe `fromdateiso8601` builtin parses datetimes in the ISO 8601\nformat to a number of seconds since the Unix epoch\n(1970-01-01T00:00:00Z).  The `todateiso8601` builtin does the\ninverse.\n\nThe `fromdate` builtin parses datetime strings.  Currently\n`fromdate` only supports ISO 8601 datetime strings, but in the\nfuture it will attempt to parse datetime strings in more\nformats.\n\nThe `todate` builtin is an alias for `todateiso8601`.\n\nThe `now` builtin outputs the current time, in seconds since\nthe Unix epoch.\n\nLow-level jq interfaces to the C-library time functions are\nalso provided: `strptime`, `strftime`, `strflocaltime`,\n`mktime`, `gmtime`, and `localtime`.  Refer to your host\noperating system's documentation for the format strings used\nby `strptime` and `strftime`.  Note: these are not necessarily\nstable interfaces in jq, particularly as to their localization\nfunctionality.\n\nThe `gmtime` builtin consumes a number of seconds since the\nUnix epoch and outputs a \"broken down time\" representation of\nGreenwhich Meridian time as an array of numbers representing\n(in this order): the year, the month (zero-based), the day of\nthe month (one-based), the hour of the day, the minute of the\nhour, the second of the minute, the day of the week, and the\nday of the year -- all one-based unless otherwise stated.  The\nday of the week number may be wrong on some systems for dates\nbefore March 1st 1900, or after December 31 2099.\n\nThe `localtime` builtin works like the `gmtime` builtin, but\nusing the local timezone setting.\n\nThe `mktime` builtin consumes \"broken down time\"\nrepresentations of time output by `gmtime` and `strptime`.\n\nThe `strptime(fmt)` builtin parses input strings matching the\n`fmt` argument.  The output is in the \"broken down time\"\nrepresentation consumed by `gmtime` and output by `mktime`.\n\nThe `strftime(fmt)` builtin formats a time (GMT) with the\ngiven format.  The `strflocaltime` does the same, but using\nthe local timezone setting.\n\nThe format strings for `strptime` and `strftime` are described\nin typical C library documentation.  The format string for ISO\n8601 datetime is `\"%Y-%m-%dT%H:%M:%SZ\"`.\n\njq may not support some or all of this date functionality on\nsome systems. In particular, the `%u` and `%j` specifiers for\n`strptime(fmt)` are not supported on macOS.\n",
          "examples": [
            {
              "program": "fromdate",
              "input": "\"2015-03-05T23:51:47Z\"",
              "output": [
                "1425599507"
              ]
            },
            {
              "program": "strptime(\"%Y-%m-%dT%H:%M:%SZ\")",
              "input": "\"2015-03-05T23:51:47Z\"",
              "output": [
                "[2015,2,5,23,51,47,4,63]"
              ]
            },
            {
              "program": "strptime(\"%Y-%m-%dT%H:%M:%SZ\")|mktime",
              "input": "\"2015-03-05T23:51:47Z\"",
              "output": [
                "1425599507"
              ]
            }
          ]
        },
        {
          "title": "SQL-Style Operators",
          "body": "\njq provides a few SQL-style operators.\n\n * INDEX(stream; index_expression):\n\n   This builtin produces an object whose keys are computed by\n   the given index expression applied to each value from the\n   given stream.\n\n * JOIN($idx; stream; idx_expr; join_expr):\n\n   This builtin joins the values from the given stream to the\n   given index.  The index's keys are computed by applying the\n   given index expression to each value from the given stream.\n   An array of the value in the stream and the corresponding\n   value from the index is fed to the given join expression to\n   produce each result.\n\n * JOIN($idx; stream; idx_expr):\n\n   Same as `JOIN($idx; stream; idx_expr; .)`.\n\n * JOIN($idx; idx_expr):\n\n   This builtin joins the input `.` to the given index, applying\n   the given index expression to `.` to compute the index key.\n   The join operation is as described above.\n\n * IN(s):\n\n   This builtin outputs `true` if `.` appears in the given\n   stream, otherwise it outputs `false`.\n\n * IN(source; s):\n\n   This builtin outputs `true` if any value in the source stream\n   appears in the second stream, otherwise it outputs `false`.\n"
        },
        {
          "title": "`builtins`",
          "body": "\nReturns a list of all builtin functions in the format `name/arity`.\nSince functions with the same name but different arities are considered\nseparate functions, `all/0`, `all/1`, and `all/2` would all be present\nin the list.\n"
        }
      ]
    },
    {
      "title": "Conditionals and Comparisons",
      "entries": [
        {
          "title": "`==`, `!=`",
          "body": "\nThe expression 'a == b' will produce 'true' if the result of a and b\nare equal (that is, if they represent equivalent JSON documents) and\n'false' otherwise. In particular, strings are never considered equal\nto numbers. If you're coming from Javascript, jq's == is like\nJavascript's === - considering values equal only when they have the\nsame type as well as the same value.\n\n!= is \"not equal\", and 'a != b' returns the opposite value of 'a == b'\n",
          "examples": [
            {
              "program": ".[] == 1",
              "input": "[1, 1.0, \"1\", \"banana\"]",
              "output": [
                "true",
                "true",
                "false",
                "false"
              ]
            }
          ]
        },
        {
          "title": "if-then-else",
          "body": "\n`if A then B else C end` will act the same as `B` if `A`\nproduces a value other than false or null, but act the same\nas `C` otherwise.\n\nChecking for false or null is a simpler notion of\n\"truthiness\" than is found in Javascript or Python, but it\nmeans that you'll sometimes have to be more explicit about\nthe condition you want: you can't test whether, e.g. a\nstring is empty using `if .name then A else B end`, you'll\nneed something more like `if (.name | length) > 0 then A else\nB end` instead.\n\nIf the condition `A` produces multiple results, then `B` is evaluated\nonce for each result that is not false or null, and `C` is evaluated\nonce for each false or null.\n\nMore cases can be added to an if using `elif A then B` syntax.\n",
          "examples": [
            {
              "program": "if . == 0 then\n  \"zero\"\nelif . == 1 then\n  \"one\"\nelse\n  \"many\"\nend",
              "input": 2,
              "output": [
                "\"many\""
              ]
            }
          ]
        },
        {
          "title": "`>, >=, <=, <`",
          "body": "\nThe comparison operators `>`, `>=`, `<=`, `<` return whether\ntheir left argument is greater than, greater than or equal\nto, less than or equal to or less than their right argument\n(respectively).\n\nThe ordering is the same as that described for `sort`, above.\n",
          "examples": [
            {
              "program": ". < 5",
              "input": 2,
              "output": [
                "true"
              ]
            }
          ]
        },
        {
          "title": "and/or/not",
          "body": "\njq supports the normal Boolean operators and/or/not. They have the\nsame standard of truth as if expressions - false and null are\nconsidered \"false values\", and anything else is a \"true value\".\n\nIf an operand of one of these operators produces multiple\nresults, the operator itself will produce a result for each input.\n\n`not` is in fact a builtin function rather than an operator,\nso it is called as a filter to which things can be piped\nrather than with special syntax, as in `.foo and .bar |\nnot`.\n\nThese three only produce the values \"true\" and \"false\", and\nso are only useful for genuine Boolean operations, rather\nthan the common Perl/Python/Ruby idiom of\n\"value_that_may_be_null or default\". If you want to use this\nform of \"or\", picking between two values rather than\nevaluating a condition, see the \"//\" operator below.\n",
          "examples": [
            {
              "program": "42 and \"a string\"",
              "input": "null",
              "output": [
                "true"
              ]
            },
            {
              "program": "(true, false) or false",
              "input": "null",
              "output": [
                "true",
                "false"
              ]
            },
            {
              "program": "(true, true) and (true, false)",
              "input": "null",
              "output": [
                "true",
                "false",
                "true",
                "false"
              ]
            },
            {
              "program": "[true, false | not]",
              "input": "null",
              "output": [
                "[false, true]"
              ]
            }
          ]
        },
        {
          "title": "Alternative operator: `//`",
          "body": "\nA filter of the form `a // b` produces the same\nresults as `a`, if `a` produces results other than `false`\nand `null`. Otherwise, `a // b` produces the same results as `b`.\n\nThis is useful for providing defaults: `.foo // 1` will\nevaluate to `1` if there's no `.foo` element in the\ninput. It's similar to how `or` is sometimes used in Python\n(jq's `or` operator is reserved for strictly Boolean\noperations).\n",
          "examples": [
            {
              "program": ".foo // 42",
              "input": "{\"foo\": 19}",
              "output": [
                19
              ]
            },
            {
              "program": ".foo // 42",
              "input": "{}",
              "output": [
                42
              ]
            }
          ]
        },
        {
          "title": "try-catch",
          "body": "\nErrors can be caught by using `try EXP catch EXP`.  The first\nexpression is executed, and if it fails then the second is\nexecuted with the error message.  The output of the handler,\nif any, is output as if it had been the output of the\nexpression to try.\n\nThe `try EXP` form uses `empty` as the exception handler.\n",
          "examples": [
            {
              "program": "try .a catch \". is not an object\"",
              "input": "true",
              "output": [
                "\". is not an object\""
              ]
            },
            {
              "program": "[.[]|try .a]",
              "input": "[{}, true, {\"a\":1}]",
              "output": [
                "[null, 1]"
              ]
            },
            {
              "program": "try error(\"some exception\") catch .",
              "input": "true",
              "output": [
                "\"some exception\""
              ]
            }
          ]
        },
        {
          "title": "Breaking out of control structures",
          "body": "\nA convenient use of try/catch is to break out of control\nstructures like `reduce`, `foreach`, `while`, and so on.\n\nFor example:\n\n    try repeat(exp) catch .==\"break\" then empty else error;\n\njq has a syntax for named lexical labels to \"break\" or \"go (back) to\":\n\n    label $out | ... break $out ...\n\nThe `break $label_name` expression will cause the program to\nto act as though the nearest (to the left) `label $label_name`\nproduced `empty`.\n\nThe relationship between the `break` and corresponding `label`\nis lexical: the label has to be \"visible\" from the break.\n\nTo break out of a `reduce`, for example:\n\n    label $out | reduce .[] as $item (null; if .==false then break $out else ... end)\n\nThe following jq program produces a syntax error:\n\n    break $out\n\nbecause no label `$out` is visible.\n"
        },
        {
          "title": "Error Suppression / Optional Operator: `?`",
          "body": "\nThe `?` operator, used as `EXP?`, is shorthand for `try EXP`.\n",
          "examples": [
            {
              "program": "[.[]|(.a)?]",
              "input": "[{}, true, {\"a\":1}]",
              "output": [
                "[null, 1]"
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "Regular expressions (PCRE)",
      "body": "\njq uses the Oniguruma regular expression library, as do php,\nruby, TextMate, Sublime Text, etc, so the description here\nwill focus on jq specifics.\n\nThe jq regex filters are defined so that they can be used using\none of these patterns:\n\n    STRING | FILTER( REGEX )\n    STRING | FILTER( REGEX; FLAGS )\n    STRING | FILTER( [REGEX] )\n    STRING | FILTER( [REGEX, FLAGS] )\n\nwhere:\n* STRING, REGEX and FLAGS are jq strings and subject to jq string interpolation;\n* REGEX, after string interpolation, should be a valid PCRE regex;\n* FILTER is one of `test`, `match`, or `capture`, as described below.\n\nFLAGS is a string consisting of one of more of the supported flags:\n\n* `g` - Global search (find all matches, not just the first)\n* `i` - Case insensitive search\n* `m` - Multi line mode ('.' will match newlines)\n* `n` - Ignore empty matches\n* `p` - Both s and m modes are enabled\n* `s` - Single line mode ('^' -> '\\A', '$' -> '\\Z')\n* `l` - Find longest possible matches\n* `x` - Extended regex format (ignore whitespace and comments)\n\nTo match whitespace in an x pattern use an escape such as \\s, e.g.\n\n* test( \"a\\\\sb\", \"x\" ).\n\nNote that certain flags may also be specified within REGEX, e.g.\n\n* jq -n '(\"test\", \"TEst\", \"teST\", \"TEST\") | test( \"(?i)te(?-i)st\" )'\n\nevaluates to: true, true, false, false.\n",
      "entries": [
        {
          "title": "`test(val)`, `test(regex; flags)`",
          "body": "\nLike `match`, but does not return match objects, only `true` or `false`\nfor whether or not the regex matches the input.\n",
          "examples": [
            {
              "program": "test(\"foo\")",
              "input": "\"foo\"",
              "output": [
                "true"
              ]
            },
            {
              "program": ".[] | test(\"a b c # spaces are ignored\"; \"ix\")",
              "input": "[\"xabcd\", \"ABC\"]",
              "output": [
                "true",
                "true"
              ]
            }
          ]
        },
        {
          "title": "`match(val)`, `match(regex; flags)`",
          "body": "\n**match** outputs an object for each match it finds.  Matches have\nthe following fields:\n\n* `offset` - offset in UTF-8 codepoints from the beginning of the input\n* `length` - length in UTF-8 codepoints of the match\n* `string` - the string that it matched\n* `captures` - an array of objects representing capturing groups.\n\nCapturing group objects have the following fields:\n\n* `offset` - offset in UTF-8 codepoints from the beginning of the input\n* `length` - length in UTF-8 codepoints of this capturing group\n* `string` - the string that was captured\n* `name` - the name of the capturing group (or `null` if it was unnamed)\n\nCapturing groups that did not match anything return an offset of -1\n",
          "examples": [
            {
              "program": "match(\"(abc)+\"; \"g\")",
              "input": "\"abc abc\"",
              "output": [
                "{\"offset\": 0, \"length\": 3, \"string\": \"abc\", \"captures\": [{\"offset\": 0, \"length\": 3, \"string\": \"abc\", \"name\": null}]}",
                "{\"offset\": 4, \"length\": 3, \"string\": \"abc\", \"captures\": [{\"offset\": 4, \"length\": 3, \"string\": \"abc\", \"name\": null}]}"
              ]
            },
            {
              "program": "match(\"foo\")",
              "input": "\"foo bar foo\"",
              "output": [
                "{\"offset\": 0, \"length\": 3, \"string\": \"foo\", \"captures\": []}"
              ]
            },
            {
              "program": "match([\"foo\", \"ig\"])",
              "input": "\"foo bar FOO\"",
              "output": [
                "{\"offset\": 0, \"length\": 3, \"string\": \"foo\", \"captures\": []}",
                "{\"offset\": 8, \"length\": 3, \"string\": \"FOO\", \"captures\": []}"
              ]
            },
            {
              "program": "match(\"foo (?<bar123>bar)? foo\"; \"ig\")",
              "input": "\"foo bar foo foo  foo\"",
              "output": [
                "{\"offset\": 0, \"length\": 11, \"string\": \"foo bar foo\", \"captures\": [{\"offset\": 4, \"length\": 3, \"string\": \"bar\", \"name\": \"bar123\"}]}",
                "{\"offset\": 12, \"length\": 8, \"string\": \"foo  foo\", \"captures\": [{\"offset\": -1, \"length\": 0, \"string\": null, \"name\": \"bar123\"}]}"
              ]
            },
            {
              "program": "[ match(\".\"; \"g\")] | length",
              "input": "\"abc\"",
              "output": [
                3
              ]
            }
          ]
        },
        {
          "title": "`capture(val)`, `capture(regex; flags)`",
          "body": "\nCollects the named captures in a JSON object, with the name\nof each capture as the key, and the matched string as the\ncorresponding value.\n",
          "examples": [
            {
              "program": "capture(\"(?<a>[a-z]+)-(?<n>[0-9]+)\")",
              "input": "\"xyzzy-14\"",
              "output": [
                "{ \"a\": \"xyzzy\", \"n\": \"14\" }"
              ]
            }
          ]
        },
        {
          "title": "`scan(regex)`, `scan(regex; flags)`",
          "body": "\nEmit a stream of the non-overlapping substrings of the input\nthat match the regex in accordance with the flags, if any\nhave been specified.  If there is no match, the stream is empty.\nTo capture all the matches for each input string, use the idiom\n`[ expr ]`, e.g. `[ scan(regex) ]`.\n",
          "example": [
            {
              "program": "scan(\"c\")",
              "input": "\"abcdefabc\"",
              "output": [
                "\"c\"",
                "\"c\""
              ]
            },
            {
              "program": "scan(\"b\")",
              "input": "(\"\", \"\")",
              "output": [
                "[]",
                "[]"
              ]
            }
          ]
        },
        {
          "title": "`split(regex; flags)`",
          "body": "\nFor backwards compatibility, `split` splits on a string, not a regex.\n",
          "example": [
            {
              "program": "split(\", *\"; null)",
              "input": "\"ab,cd, ef\"",
              "output": [
                "\"ab\",\"cd\",\"ef\""
              ]
            }
          ]
        },
        {
          "title": "`splits(regex)`, `splits(regex; flags)`",
          "body": "\nThese provide the same results as their `split` counterparts,\nbut as a stream instead of an array.\n",
          "example": [
            {
              "program": "splits(\", *\")",
              "input": "(\"ab,cd\", \"ef, gh\")",
              "output": [
                "\"ab\"",
                "\"cd\"",
                "\"ef\"",
                "\"gh\""
              ]
            }
          ]
        },
        {
          "title": "`sub(regex; tostring)` `sub(regex; string; flags)`",
          "body": "\nEmit the string obtained by replacing the first match of regex in the\ninput string with `tostring`, after interpolation.  `tostring` should\nbe a jq string, and may contain references to named captures. The\nnamed captures are, in effect, presented as a JSON object (as\nconstructed by `capture`) to `tostring`, so a reference to a captured\nvariable named \"x\" would take the form: \"\\(.x)\".\n",
          "example": [
            {
              "program": "sub(\"^[^a-z]*(?<x>[a-z]*).*\")",
              "input": "\"123abc456\"",
              "output": "\"ZabcZabc\""
            }
          ]
        },
        {
          "title": "`gsub(regex; string)`, `gsub(regex; string; flags)`",
          "body": "\n`gsub` is like `sub` but all the non-overlapping occurrences of the regex are\nreplaced by the string, after interpolation.\n",
          "example": [
            {
              "program": "gsub(\"(?<x>.)[^a]*\"; \"+\\(.x)-\")",
              "input": "\"Abcabc\"",
              "output": "\"+A-+a-\""
            }
          ]
        }
      ]
    },
    {
      "title": "Advanced features",
      "body": "Variables are an absolute necessity in most programming languages, but\nthey're relegated to an \"advanced feature\" in jq.\n\nIn most languages, variables are the only means of passing around\ndata. If you calculate a value, and you want to use it more than once,\nyou'll need to store it in a variable. To pass a value to another part\nof the program, you'll need that part of the program to define a\nvariable (as a function parameter, object member, or whatever) in\nwhich to place the data.\n\nIt is also possible to define functions in jq, although this is\nis a feature whose biggest use is defining jq's standard library\n(many jq functions such as `map` and `find` are in fact written\nin jq).\n\njq has reduction operators, which are very powerful but a bit\ntricky.  Again, these are mostly used internally, to define some\nuseful bits of jq's standard library.\n\nIt may not be obvious at first, but jq is all about generators\n(yes, as often found in other languages).  Some utilities are\nprovided to help deal with generators.\n\nSome minimal I/O support (besides reading JSON from standard\ninput, and writing JSON to standard output) is available.\n\nFinally, there is a module/library system.\n",
      "entries": [
        {
          "title": "Variable / Symbolic Binding Operator: `... as $identifier | ...`",
          "body": "\nIn jq, all filters have an input and an output, so manual\nplumbing is not necessary to pass a value from one part of a program\nto the next. Many expressions, for instance `a + b`, pass their input\nto two distinct subexpressions (here `a` and `b` are both passed the\nsame input), so variables aren't usually necessary in order to use a\nvalue twice.\n\nFor instance, calculating the average value of an array of numbers\nrequires a few variables in most languages - at least one to hold the\narray, perhaps one for each element or for a loop counter. In jq, it's\nsimply `add / length` - the `add` expression is given the array and\nproduces its sum, and the `length` expression is given the array and\nproduces its length.\n\nSo, there's generally a cleaner way to solve most problems in jq than\ndefining variables. Still, sometimes they do make things easier, so jq\nlets you define variables using `expression as $variable`. All\nvariable names start with `$`. Here's a slightly uglier version of the\narray-averaging example:\n\n    length as $array_length | add / $array_length\n\nWe'll need a more complicated problem to find a situation where using\nvariables actually makes our lives easier.\n\n\nSuppose we have an array of blog posts, with \"author\" and \"title\"\nfields, and another object which is used to map author usernames to\nreal names. Our input looks like:\n\n    {\"posts\": [{\"title\": \"Frist psot\", \"author\": \"anon\"},\n               {\"title\": \"A well-written article\", \"author\": \"person1\"}],\n     \"realnames\": {\"anon\": \"Anonymous Coward\",\n                   \"person1\": \"Person McPherson\"}}\n\nWe want to produce the posts with the author field containing a real\nname, as in:\n\n    {\"title\": \"Frist psot\", \"author\": \"Anonymous Coward\"}\n    {\"title\": \"A well-written article\", \"author\": \"Person McPherson\"}\n\nWe use a variable, $names, to store the realnames object, so that we\ncan refer to it later when looking up author usernames:\n\n    .realnames as $names | .posts[] | {title, author: $names[.author]}\n\nThe expression `exp as $x | ...` means: for each value of expression\n`exp`, run the rest of the pipeline with the entire original input, and\nwith `$x` set to that value.  Thus `as` functions as something of a\nforeach loop.\n\nJust as `{foo}` is a handy way of writing `{foo: .foo}`, so\n`{$foo}` is a handy way of writing `{foo:$foo}`.\n\nMultiple variables may be declared using a single `as` expression by\nproviding a pattern that matches the structure of the input\n(this is known as \"destructuring\"):\n\n    . as {realnames: $names, posts: [$first, $second]} | ...\n\nThe variable declarations in array patterns (e.g., `. as\n[$first, $second]`) bind to the elements of the array in from\nthe element at index zero on up, in order.  When there is no\nvalue at the index for an array pattern element, `null` is\nbound to that variable.\n\nVariables are scoped over the rest of the expression that defines\nthem, so\n\n    .realnames as $names | (.posts[] | {title, author: $names[.author]})\n\nwill work, but\n\n    (.realnames as $names | .posts[]) | {title, author: $names[.author]}\n\nwon't.\n\nFor programming language theorists, it's more accurate to\nsay that jq variables are lexically-scoped bindings.  In\nparticular there's no way to change the value of a binding;\none can only setup a new binding with the same name, but which\nwill not be visible where the old one was.\n",
          "examples": [
            {
              "program": ".bar as $x | .foo | . + $x",
              "input": "{\"foo\":10, \"bar\":200}",
              "output": [
                "210"
              ]
            },
            {
              "program": ". as $i|[(.*2|. as $i| $i), $i]",
              "input": "5",
              "output": [
                "[10,5]"
              ]
            },
            {
              "program": ". as [$a, $b, {c: $c}] | $a + $b + $c",
              "input": "[2, 3, {\"c\": 4, \"d\": 5}]",
              "output": [
                "9"
              ]
            },
            {
              "program": ".[] as [$a, $b] | {a: $a, b: $b}",
              "input": "[[0], [0, 1], [2, 1, 0]]",
              "output": [
                "{\"a\":0,\"b\":null}",
                "{\"a\":0,\"b\":1}",
                "{\"a\":2,\"b\":1}"
              ]
            }
          ]
        },
        {
          "title": "Destructuring Alternative Operator: `?//`",
          "body": "\nThe destructuring alternative operator provides a concise mechanism\nfor destructuring an input that can take one of several forms.\n\nSuppose we have an API that returns a list of resources and events\nassociated with them, and we want to get the user_id and timestamp of\nthe first event for each resource. The API (having been clumsily\nconverted from XML) will only wrap the events in an array if the resource\nhas multiple events:\n\n    {\"resources\": [{\"id\": 1, \"kind\": \"widget\", \"events\": {\"action\": \"create\", \"user_id\": 1, \"ts\": 13}},\n                   {\"id\": 2, \"kind\": \"widget\", \"events\": [{\"action\": \"create\", \"user_id\": 1, \"ts\": 14}, {\"action\": \"destroy\", \"user_id\": 1, \"ts\": 15}]}]}\n\nWe can use the destructuring alternative operator to handle this structural change simply:\n\n    .resources[] as {$id, $kind, events: {$user_id, $ts}} ?// {$id, $kind, events: [{$user_id, $ts}]} | {$user_id, $kind, $id, $ts}\n\nOr, if we aren't sure if the input is an array of values or an object:\n\n    .[] as [$id, $kind, $user_id, $ts] ?// {$id, $kind, $user_id, $ts} | ...\n\nEach alternative need not define all of the same variables, but all named\nvariables will be available to the subsequent expression. Variables not\nmatched in the alternative that succeeded will be `null`:\n\n    .resources[] as {$id, $kind, events: {$user_id, $ts}} ?// {$id, $kind, events: [{$first_user_id, $first_ts}]} | {$user_id, $first_user_id, $kind, $id, $ts, $first_ts}\n\nAdditionally, if the subsequent expression returns an error, the\nalternative operator will attempt to try the next binding. Errors\nthat occur during the final alternative are passed through.\n\n    [[3]] | .[] as [$a] ?// [$b] | if $a != null then error(\"err: \\($a)\") else {$a,$b} end\n",
          "examples": [
            {
              "program": ".[] as {$a, $b, c: {$d, $e}} ?// {$a, $b, c: [{$d, $e}]} | {$a, $b, $d, $e}",
              "input": "[{\"a\": 1, \"b\": 2, \"c\": {\"d\": 3, \"e\": 4}}, {\"a\": 1, \"b\": 2, \"c\": [{\"d\": 3, \"e\": 4}]}]",
              "output": [
                "{\"a\":1,\"b\":2,\"d\":3,\"e\":4}",
                "{\"a\":1,\"b\":2,\"d\":3,\"e\":4}"
              ]
            },
            {
              "program": ".[] as {$a, $b, c: {$d}} ?// {$a, $b, c: [{$e}]} | {$a, $b, $d, $e}",
              "input": "[{\"a\": 1, \"b\": 2, \"c\": {\"d\": 3, \"e\": 4}}, {\"a\": 1, \"b\": 2, \"c\": [{\"d\": 3, \"e\": 4}]}]",
              "output": [
                "{\"a\":1,\"b\":2,\"d\":3,\"e\":null}",
                "{\"a\":1,\"b\":2,\"d\":null,\"e\":4}"
              ]
            },
            {
              "program": ".[] as [$a] ?// [$b] | if $a != null then error(\"err: \\($a)\") else {$a,$b} end",
              "input": "[[3]]",
              "output": [
                "{\"a\":null,\"b\":3}"
              ]
            }
          ]
        },
        {
          "title": "Defining Functions",
          "body": "\nYou can give a filter a name using \"def\" syntax:\n\n    def increment: . + 1;\n\nFrom then on, `increment` is usable as a filter just like a\nbuiltin function (in fact, this is how many of the builtins\nare defined). A function may take arguments:\n\n    def map(f): [.[] | f];\n\nArguments are passed as _filters_ (functions with no\narguments), _not_ as values. The same argument may be\nreferenced multiple times with different inputs (here `f` is\nrun for each element of the input array).  Arguments to a\nfunction work more like callbacks than like value arguments.\nThis is important to understand.  Consider:\n\n    def foo(f): f|f;\n    5|foo(.*2)\n\nThe result will be 20 because `f` is `.*2`, and during the\nfirst invocation of `f` `.` will be 5, and the second time it\nwill be 10 (5 * 2), so the result will be 20.  Function\narguments are filters, and filters expect an input when\ninvoked.\n\nIf you want the value-argument behaviour for defining simple\nfunctions, you can just use a variable:\n\n    def addvalue(f): f as $f | map(. + $f);\n\nOr use the short-hand:\n\n    def addvalue($f): ...;\n\nWith either definition, `addvalue(.foo)` will add the current\ninput's `.foo` field to each element of the array.  Do note\nthat calling `addvalue(.[])` will cause the `map(. + $f)` part\nto be evaluated once per value in the value of `.` at the call\nsite.\n\nMultiple definitions using the same function name are allowed.\nEach re-definition replaces the previous one for the same\nnumber of function arguments, but only for references from\nfunctions (or main program) subsequent to the re-definition.\nSee also the section below on scoping.\n",
          "examples": [
            {
              "program": "def addvalue(f): . + [f]; map(addvalue(.[0]))",
              "input": "[[1,2],[10,20]]",
              "output": [
                "[[1,2,1], [10,20,10]]"
              ]
            },
            {
              "program": "def addvalue(f): f as $x | map(. + $x); addvalue(.[0])",
              "input": "[[1,2],[10,20]]",
              "output": [
                "[[1,2,1,2], [10,20,1,2]]"
              ]
            }
          ]
        },
        {
          "title": "Scoping",
          "body": "\nThere are two types of symbols in jq: value bindings (a.k.a.,\n\"variables\"), and functions.  Both are scoped lexically,\nwith expressions being able to refer only to symbols that\nhave been defined \"to the left\" of them.  The only exception\nto this rule is that functions can refer to themselves so as\nto be able to create recursive functions.\n\nFor example, in the following expression there is a binding\nwhich is visible \"to the right\" of it, `... | .*3 as\n$times_three | [.  + $times_three] | ...`, but not \"to the\nleft\".  Consider this expression now, `... | (.*3 as\n$times_three | [.+ $times_three]) | ...`: here the binding\n`$times_three` is _not_ visible past the closing parenthesis.\n"
        },
        {
          "title": "Reduce",
          "body": "\nThe `reduce` syntax in jq allows you to combine all of the\nresults of an expression by accumulating them into a single\nanswer. As an example, we'll pass `[3,2,1]` to this expression:\n\n    reduce .[] as $item (0; . + $item)\n\nFor each result that `.[]` produces, `. + $item` is run to\naccumulate a running total, starting from 0. In this\nexample, `.[]` produces the results 3, 2, and 1, so the\neffect is similar to running something like this:\n\n    0 | (3 as $item | . + $item) |\n        (2 as $item | . + $item) |\n        (1 as $item | . + $item)\n",
          "examples": [
            {
              "program": "reduce .[] as $item (0; . + $item)",
              "input": "[10,2,5,3]",
              "output": [
                "20"
              ]
            }
          ]
        },
        {
          "title": "`isempty(exp)`",
          "body": "\nReturns true if `exp` produces no outputs, false otherwise.\n",
          "examples": [
            {
              "program": "isempty(empty)",
              "input": "null",
              "output": [
                "true"
              ]
            }
          ]
        },
        {
          "title": "`limit(n; exp)`",
          "body": "\nThe `limit` function extracts up to `n` outputs from `exp`.\n",
          "examples": [
            {
              "program": "[limit(3;.[])]",
              "input": "[0,1,2,3,4,5,6,7,8,9]",
              "output": [
                "[0,1,2]"
              ]
            }
          ]
        },
        {
          "title": "`first(expr)`, `last(expr)`, `nth(n; expr)`",
          "body": "\nThe `first(expr)` and `last(expr)` functions extract the first\nand last values from `expr`, respectively.\n\nThe `nth(n; expr)` function extracts the nth value output by\n`expr`.  This can be defined as `def nth(n; expr):\nlast(limit(n + 1; expr));`.  Note that `nth(n; expr)` doesn't\nsupport negative values of `n`.\n",
          "examples": [
            {
              "program": "[first(range(.)), last(range(.)), nth(./2; range(.))]",
              "input": "10",
              "output": [
                "[0,9,5]"
              ]
            }
          ]
        },
        {
          "title": "`first`, `last`, `nth(n)`",
          "body": "\nThe `first` and `last` functions extract the first\nand last values from any array at `.`.\n\nThe `nth(n)` function extracts the nth value of any array at `.`.\n",
          "examples": [
            {
              "program": "[range(.)]|[first, last, nth(5)]",
              "input": "10",
              "output": [
                "[0,9,5]"
              ]
            }
          ]
        },
        {
          "title": "`foreach`",
          "body": "\nThe `foreach` syntax is similar to `reduce`, but intended to\nallow the construction of `limit` and reducers that produce\nintermediate results (see example).\n\nThe form is `foreach EXP as $var (INIT; UPDATE; EXTRACT)`.\nLike `reduce`, `INIT` is evaluated once to produce a state\nvalue, then each output of `EXP` is bound to `$var`, `UPDATE`\nis evaluated for each output of `EXP` with the current state\nand with `$var` visible.  Each value output by `UPDATE`\nreplaces the previous state.  Finally, `EXTRACT` is evaluated\nfor each new state to extract an output of `foreach`.\n\nThis is mostly useful only for constructing `reduce`- and\n`limit`-like functions.  But it is much more general, as it\nallows for partial reductions (see the example below).\n",
          "examples": [
            {
              "program": "[foreach .[] as $item\n([[],[]];\nif $item == null then [[],.[0]] else [(.[0] + [$item]),[]] end;\nif $item == null then .[1] else empty end)]",
              "input": "[1,2,3,4,null,\"a\",\"b\",null]",
              "output": [
                "[[1,2,3,4],[\"a\",\"b\"]]"
              ]
            }
          ]
        },
        {
          "title": "Recursion",
          "body": "\nAs described above, `recurse` uses recursion, and any jq\nfunction can be recursive.  The `while` builtin is also\nimplemented in terms of recursion.\n\nTail calls are optimized whenever the expression to the left of\nthe recursive call outputs its last value.  In practice this\nmeans that the expression to the left of the recursive call\nshould not produce more than one output for each input.\n\nFor example:\n\n    def recurse(f): def r: ., (f | select(. != null) | r); r;\n\n    def while(cond; update):\n      def _while:\n        if cond then ., (update | _while) else empty end;\n      _while;\n\n    def repeat(exp):\n      def _repeat:\n        exp, _repeat;\n      _repeat;\n"
        },
        {
          "title": "Generators and iterators",
          "body": "\nSome jq operators and functions are actually generators in\nthat they can produce zero, one, or more values for each\ninput, just as one might expect in other programming\nlanguages that have generators.  For example, `.[]`\ngenerates all the values in its input (which must be an\narray or an object), `range(0; 10)` generates the integers\nbetween 0 and 10, and so on.\n\nEven the comma operator is a generator, generating first the\nvalues generated by the expression to the left of the comma,\nthen for each of those, the values generate by the\nexpression on the right of the comma.\n\nThe `empty` builtin is the generator that produces zero\noutputs.  The `empty` builtin backtracks to the preceding\ngenerator expression.\n\nAll jq functions can be generators just by using builtin\ngenerators.  It is also possible to define new generators\nusing only recursion and the comma operator.  If the\nrecursive call(s) is(are) \"in tail position\" then the\ngenerator will be efficient.  In the example below the\nrecursive call by `_range` to itself is in tail position.\nThe example shows off three advanced topics: tail recursion,\ngenerator construction, and sub-functions.\n",
          "examples": [
            {
              "program": "def range(init; upto; by):\ndef _range:\nif (by > 0 and . < upto) or (by < 0 and . > upto)\nthen ., ((.+by)|_range)\nelse . end;\nif by == 0 then init else init|_range end |\nselect((by > 0 and . < upto) or (by < 0 and . > upto));\nrange(0; 10; 3)",
              "input": "null",
              "output": [
                "0",
                "3",
                "6",
                "9"
              ]
            },
            {
              "program": "def while(cond; update):\ndef _while:\nif cond then ., (update | _while) else empty end;\n_while;\n[while(.<100; .*2)]",
              "input": "1",
              "output": [
                "[1,2,4,8,16,32,64]"
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "Math",
      "body": "\njq currently only has IEEE754 double-precision (64-bit) floating\npoint number support.\n\nBesides simple arithmetic operators such as `+`, jq also has most\nstandard math functions from the C math library.  C math functions\nthat take a single input argument (e.g., `sin()`) are available as\nzero-argument jq functions.  C math functions that take two input\narguments (e.g., `pow()`) are available as two-argument jq\nfunctions that ignore `.`.  C math functions that take three input\narguments are available as three-argument jq functions that ignore\n`.`.\n\nAvailability of standard math functions depends on the\navailability of the corresponding math functions in your operating\nsystem and C math library.  Unavailable math functions will be\ndefined but will raise an error.\n\nOne-input C math functions: `acos` `acosh` `asin` `asinh` `atan`\n`atanh` `cbrt` `ceil` `cos` `cosh` `erf` `erfc` `exp` `exp10`\n`exp2` `expm1` `fabs` `floor` `gamma` `j0` `j1` `lgamma` `log`\n`log10` `log1p` `log2` `logb` `nearbyint` `pow10` `rint` `round`\n`significand` `sin` `sinh` `sqrt` `tan` `tanh` `tgamma` `trunc`\n`y0` `y1`.\n\nTwo-input C math functions: `atan2` `copysign` `drem` `fdim`\n`fmax` `fmin` `fmod` `frexp` `hypot` `jn` `ldexp` `modf`\n`nextafter` `nexttoward` `pow` `remainder` `scalb` `scalbln` `yn`.\n\nThree-input C math functions: `fma`.\n\nSee your system's manual for more information on each of these.\n"
    },
    {
      "title": "I/O",
      "body": "\nAt this time jq has minimal support for I/O, mostly in the\nform of control over when inputs are read.  Two builtins functions\nare provided for this, `input` and `inputs`, that read from the\nsame sources (e.g., `stdin`, files named on the command-line) as\njq itself.  These two builtins, and jq's own reading actions, can\nbe interleaved with each other.\n\nTwo builtins provide minimal output capabilities, `debug`, and\n`stderr`.  (Recall that a jq program's output values are always\noutput as JSON texts on `stdout`.)  The `debug` builtin can have\napplication-specific behavior, such as for executables that use\nthe libjq C API but aren't the jq executable itself.  The `stderr`\nbuiltin outputs its input in raw mode to stder with no additional\ndecoration, not even a newline.\n\nMost jq builtins are referentially transparent, and yield constant\nand repeatable value streams when applied to constant inputs.\nThis is not true of I/O builtins.\n",
      "entries": [
        {
          "title": "`input`",
          "body": "\nOutputs one new input.\n"
        },
        {
          "title": "`inputs`",
          "body": "\nOutputs all remaining inputs, one by one.\n\nThis is primarily useful for reductions over a program's\ninputs.\n"
        },
        {
          "title": "`debug`",
          "body": "\nCauses a debug message based on the input value to be\nproduced.  The jq executable wraps the input value with\n`[\"DEBUG:\", <input-value>]` and prints that and a newline on\nstderr, compactly.  This may change in the future.\n"
        },
        {
          "title": "`stderr`",
          "body": "\nPrints its input in raw and compact mode to stderr with no\nadditional decoration, not even a newline.\n"
        },
        {
          "title": "`input_filename`",
          "body": "\nReturns the name of the file whose input is currently being\nfiltered.  Note that this will not work well unless jq is\nrunning in a UTF-8 locale.\n"
        },
        {
          "title": "`input_line_number`",
          "body": "\nReturns the line number of the input currently being filtered.\n"
        }
      ]
    },
    {
      "title": "Streaming",
      "body": "\nWith the `--stream` option jq can parse input texts in a streaming\nfashion, allowing jq programs to start processing large JSON texts\nimmediately rather than after the parse completes.  If you have a\nsingle JSON text that is 1GB in size, streaming it will allow you\nto process it much more quickly.\n\nHowever, streaming isn't easy to deal with as the jq program will\nhave `[<path>, <leaf-value>]` (and a few other forms) as inputs.\n\nSeveral builtins are provided to make handling streams easier.\n\nThe examples below use the streamed form of `[0,[1]]`, which is\n`[[0],0],[[1,0],1],[[1,0]],[[1]]`.\n\nStreaming forms include `[<path>, <leaf-value>]` (to indicate any\nscalar value, empty array, or empty object), and `[<path>]` (to\nindicate the end of an array or object).  Future versions of jq\nrun with `--stream` and `-seq` may output additional forms such as\n`[\"error message\"]` when an input text fails to parse.\n",
      "entries": [
        {
          "title": "`truncate_stream(stream_expression)`",
          "body": "\nConsumes a number as input and truncates the corresponding\nnumber of path elements from the left of the outputs of the\ngiven streaming expression.\n",
          "examples": [
            {
              "program": "[1|truncate_stream([[0],1],[[1,0],2],[[1,0]],[[1]])]",
              "input": "1",
              "output": [
                "[[[0],2],[[0]]]"
              ]
            }
          ]
        },
        {
          "title": "`fromstream(stream_expression)`",
          "body": "\nOutputs values corresponding to the stream expression's\noutputs.\n",
          "examples": [
            {
              "program": "fromstream(1|truncate_stream([[0],1],[[1,0],2],[[1,0]],[[1]]))",
              "input": "null",
              "output": [
                "[2]"
              ]
            }
          ]
        },
        {
          "title": "`tostream`",
          "body": "\nThe `tostream` builtin outputs the streamed form of its input.\n",
          "examples": [
            {
              "program": ". as $dot|fromstream($dot|tostream)|.==$dot",
              "input": "[0,[1,{\"a\":1},{\"b\":2}]]",
              "output": [
                "true"
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "Assignment",
      "body": "Assignment works a little differently in jq than in most\nprogramming languages. jq doesn't distinguish between references\nto and copies of something - two objects or arrays are either\nequal or not equal, without any further notion of being \"the\nsame object\" or \"not the same object\".\n\nIf an object has two fields which are arrays, `.foo` and `.bar`,\nand you append something to `.foo`, then `.bar` will not get\nbigger, even if you've previously set `.bar = .foo`.  If you're\nused to programming in languages like Python, Java, Ruby,\nJavascript, etc. then you can think of it as though jq does a full\ndeep copy of every object before it does the assignment (for\nperformance it doesn't actually do that, but that's the general\nidea).\n\nThis means that it's impossible to build circular values in jq\n(such as an array whose first element is itself). This is quite\nintentional, and ensures that anything a jq program can produce\ncan be represented in JSON.\n\nAll the assignment operators in jq have path expressions on the\nleft-hand side (LHS).  The right-hand side (RHS) provides values\nto set to the paths named by the LHS path expressions.\n\nValues in jq are always immutable.  Internally, assignment works\nby using a reduction to compute new, replacement values for `.` that\nhave had all the desired assignments applied to `.`, then\noutputting the modified value.  This might be made clear by this\nexample: `{a:{b:{c:1}}} | (.a.b|=3), .`.  This will output\n`{\"a\":{\"b\":3}}` and `{\"a\":{\"b\":{\"c\":1}}}` because the last\nsub-expression, `.`, sees the original value, not the modified\nvalue.\n\nMost users will want to use modification assignment operators,\nsuch as `|=` or `+=`, rather than `=`.\n\nNote that the LHS of assignment operators refers to a value in\n`.`.  Thus `$var.foo = 1` won't work as expected (`$var.foo` is\nnot a valid or useful path expression in `.`); use `$var | .foo =\n1` instead.\n\nNote too that `.a,.b=0` does not set `.a` and `.b`, but\n`(.a,.b)=0` sets both.\n",
      "entries": [
        {
          "title": "Update-assignment: `|=`",
          "body": "This is the \"update\" operator '|='.  It takes a filter on the\nright-hand side and works out the new value for the property\nof `.` being assigned to by running the old value through this\nexpression. For instance, (.foo, .bar) |= .+1 will build an\nobject with the \"foo\" field set to the input's \"foo\" plus 1,\nand the \"bar\" field set to the input's \"bar\" plus 1.\n\nThe left-hand side can be any general path expression; see `path()`.\n\nNote that the left-hand side of '|=' refers to a value in `.`.\nThus `$var.foo |= . + 1` won't work as expected (`$var.foo` is\nnot a valid or useful path expression in `.`); use `$var |\n.foo |= . + 1` instead.\n\nIf the right-hand side outputs no values (i.e., `empty`), then\nthe left-hand side path will be deleted, as with `del(path)`.\n\nIf the right-hand side outputs multiple values, only the first\none will be used (COMPATIBILITY NOTE: in jq 1.5 and earlier\nreleases, it used to be that only the last one was used).\n",
          "examples": [
            {
              "program": "(..|select(type==\"boolean\")) |= if . then 1 else 0 end",
              "input": "[true,false,[5,true,[true,[false]],false]]",
              "output": [
                "[1,0,[5,1,[1,[0]],0]]"
              ]
            }
          ]
        },
        {
          "title": "Arithmetic update-assignment: `+=`, `-=`, `*=`, `/=`, `%=`, `//=`",
          "body": "\njq has a few operators of the form `a op= b`, which are all\nequivalent to `a |= . op b`. So, `+= 1` can be used to\nincrement values, being the same as `|= . + 1`.\n",
          "examples": [
            {
              "program": ".foo += 1",
              "input": "{\"foo\": 42}",
              "output": [
                "{\"foo\": 43}"
              ]
            }
          ]
        },
        {
          "title": "Plain assignment: `=`",
          "body": "\nThis is the plain assignment operator.  Unlike the others, the\ninput to the right-hand-side (RHS) is the same as the input to\nthe left-hand-side (LHS) rather than the value at the LHS\npath, and all values output by the RHS will be used (as shown\nbelow).\n\nIf the RHS of '=' produces multiple values, then for each such\nvalue jq will set the paths on the left-hand side to the value\nand then it will output the modified `.`.  For example,\n`(.a,.b)=range(2)` outputs `{\"a\":0,\"b\":0}`, then\n`{\"a\":1,\"b\":1}`.  The \"update\" assignment forms (see above) do\nnot do this.\n\nThis example should show the difference between '=' and '|=':\n\nProvide input '{\"a\": {\"b\": 10}, \"b\": 20}' to the programs:\n\n.a = .b\n\n.a |= .b\n\nThe former will set the \"a\" field of the input to the \"b\"\nfield of the input, and produce the output {\"a\": 20, \"b\": 20}.\nThe latter will set the \"a\" field of the input to the \"a\"\nfield's \"b\" field, producing {\"a\": 10, \"b\": 20}.\n\nAnother example of the difference between '=' and '|=':\n\nnull|(.a,.b)=range(3)\n\noutputs '{\"a\":0,\"b\":0}', '{\"a\":1,\"b\":1}', and '{\"a\":2,\"b\":2}',\nwhile\n\nnull|(.a,.b)|=range(3)\n\noutputs just '{\"a\":0,\"b\":0}'.\n"
        },
        {
          "title": "Complex assignments",
          "body": "Lots more things are allowed on the left-hand side of a jq assignment\nthan in most languages. We've already seen simple field accesses on\nthe left hand side, and it's no surprise that array accesses work just\nas well:\n\n    .posts[0].title = \"JQ Manual\"\n\nWhat may come as a surprise is that the expression on the left may\nproduce multiple results, referring to different points in the input\ndocument:\n\n    .posts[].comments |= . + [\"this is great\"]\n\nThat example appends the string \"this is great\" to the \"comments\"\narray of each post in the input (where the input is an object with a\nfield \"posts\" which is an array of posts).\n\nWhen jq encounters an assignment like 'a = b', it records the \"path\"\ntaken to select a part of the input document while executing a. This\npath is then used to find which part of the input to change while\nexecuting the assignment. Any filter may be used on the\nleft-hand side of an equals - whichever paths it selects from the\ninput will be where the assignment is performed.\n\nThis is a very powerful operation. Suppose we wanted to add a comment\nto blog posts, using the same \"blog\" input above. This time, we only\nwant to comment on the posts written by \"stedolan\". We can find those\nposts using the \"select\" function described earlier:\n\n    .posts[] | select(.author == \"stedolan\")\n\nThe paths provided by this operation point to each of the posts that\n\"stedolan\" wrote, and we can comment on each of them in the same way\nthat we did before:\n\n    (.posts[] | select(.author == \"stedolan\") | .comments) |=\n        . + [\"terrible.\"]\n"
        }
      ]
    },
    {
      "title": "Modules",
      "body": "\njq has a library/module system.  Modules are files whose names end\nin `.jq`.\n\nModules imported by a program are searched for in a default search\npath (see below).  The `import` and `include` directives allow the\nimporter to alter this path.\n\nPaths in the a search path are subject to various substitutions.\n\nFor paths starting with \"~/\", the user's home directory is\nsubstituted for \"~\".\n\nFor paths starting with \"$ORIGIN/\", the path of the jq executable\nis substituted for \"$ORIGIN\".\n\nFor paths starting with \"./\" or paths that are \".\", the path of\nthe including file is substituted for \".\".  For top-level programs\ngiven on the command-line, the current directory is used.\n\nImport directives can optionally specify a search path to which\nthe default is appended.\n\nThe default search path is the search path given to the `-L`\ncommand-line option, else `[\"~/.jq\", \"$ORIGIN/../lib/jq\",\n\"$ORIGIN/../lib\"]`.\n\nNull and empty string path elements terminate search path\nprocessing.\n\nA dependency with relative path \"foo/bar\" would be searched for in\n\"foo/bar.jq\" and \"foo/bar/bar.jq\" in the given search path. This\nis intended to allow modules to be placed in a directory along\nwith, for example, version control files, README files, and so on,\nbut also to allow for single-file modules.\n\nConsecutive components with the same name are not allowed to avoid\nambiguities (e.g., \"foo/foo\").\n\nFor example, with `-L$HOME/.jq` a module `foo` can be found in\n`$HOME/.jq/foo.jq` and `$HOME/.jq/foo/foo.jq`.\n\nIf \"$HOME/.jq\" is a file, it is sourced into the main program.\n",
      "entries": [
        {
          "title": "`import RelativePathString as NAME [<metadata>];`",
          "body": "\nImports a module found at the given path relative to a\ndirectory in a search path.  A \".jq\" suffix will be added to\nthe relative path string.  The module's symbols are prefixed\nwith \"NAME::\".\n\nThe optional metadata must be a constant jq expression.  It\nshould be an object with keys like \"homepage\" and so on.  At\nthis time jq only uses the \"search\" key/value of the metadata.\nThe metadata is also made available to users via the\n`modulemeta` builtin.\n\nThe \"search\" key in the metadata, if present, should have a\nstring or array value (array of strings); this is the search\npath to be prefixed to the top-level search path.\n"
        },
        {
          "title": "`include RelativePathString [<metadata>];`",
          "body": "\nImports a module found at the given path relative to a\ndirectory in a search path as if it were included in place.  A\n\".jq\" suffix will be added to the relative path string.  The\nmodule's symbols are imported into the caller's namespace as\nif the module's content had been included directly.\n\nThe optional metadata must be a constant jq expression.  It\nshould be an object with keys like \"homepage\" and so on.  At\nthis time jq only uses the \"search\" key/value of the metadata.\nThe metadata is also made available to users via the\n`modulemeta` builtin.\n"
        },
        {
          "title": "`import RelativePathString as $NAME [<metadata>];`",
          "body": "\nImports a JSON file found at the given path relative to a\ndirectory in a search path.  A \".json\" suffix will be added to\nthe relative path string.  The file's data will be available\nas `$NAME::NAME`.\n\nThe optional metadata must be a constant jq expression.  It\nshould be an object with keys like \"homepage\" and so on.  At\nthis time jq only uses the \"search\" key/value of the metadata.\nThe metadata is also made available to users via the\n`modulemeta` builtin.\n\nThe \"search\" key in the metadata, if present, should have a\nstring or array value (array of strings); this is the search\npath to be prefixed to the top-level search path.\n"
        },
        {
          "title": "`module <metadata>;`",
          "body": "\nThis directive is entirely optional.  It's not required for\nproper operation.  It serves only the purpose of providing\nmetadata that can be read with the `modulemeta` builtin.\n\nThe metadata must be a constant jq expression.  It should be\nan object with keys like \"homepage\".  At this time jq doesn't\nuse this metadata, but it is made available to users via the\n`modulemeta` builtin.\n"
        },
        {
          "title": "`modulemeta`",
          "body": "\nTakes a module name as input and outputs the module's metadata\nas an object, with the module's imports (including metadata)\nas an array value for the \"deps\" key.\n\nPrograms can use this to query a module's metadata, which they\ncould then use to, for example, search for, download, and\ninstall missing dependencies.\n"
        }
      ]
    },
    {
      "title": "Colors",
      "body": "\nTo configure alternative colors just set the `JQ_COLORS`\nenvironment variable to colon-delimited list of partial terminal\nescape sequences like `\"1;31\"`, in this order:\n\n  - color for `null`\n  - color for `false`\n  - color for `true`\n  - color for numbers\n  - color for strings\n  - color for arrays\n  - color for objects\n\nThe default color scheme is the same as setting\n`\"JQ_COLORS=1;30:0;39:0;39:0;39:0;32:1;39:1;39\"`.\n\nThis is not a manual for VT100/ANSI escapes.  However, each of\nthese color specifications should consist of two numbers separated\nby a semi-colon, where the first number is one of these:\n\n  - 1 (bright)\n  - 2 (dim)\n  - 4 (underscore)\n  - 5 (blink)\n  - 7 (reverse)\n  - 8 (hidden)\n\nand the second is one of these:\n\n  - 30 (black)\n  - 31 (red)\n  - 32 (green)\n  - 33 (yellow)\n  - 34 (blue)\n  - 35 (magenta)\n  - 36 (cyan)\n  - 37 (white)\n"
    }
  ]
}