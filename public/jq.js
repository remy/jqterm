(() => {
  // these are the builtins via `builtins | sort | map(split("/")[0]) | unique`
  const keywords = [
    'IN',
    'INDEX',
    'JOIN',
    'abs',
    'acos',
    'acosh',
    'add',
    'all',
    'any',
    'arrays',
    'ascii_downcase',
    'ascii_upcase',
    'asin',
    'asinh',
    'atan',
    'atan2',
    'atanh',
    'booleans',
    'bsearch',
    'builtins',
    'capture',
    'cbrt',
    'ceil',
    'combinations',
    'contains',
    'copysign',
    'cos',
    'cosh',
    'debug',
    'del',
    'delpaths',
    'drem',
    'empty',
    'endswith',
    'env',
    'erf',
    'erfc',
    'error',
    'exp',
    'exp10',
    'exp2',
    'explode',
    'expm1',
    'fabs',
    'fdim',
    'finites',
    'first',
    'flatten',
    'floor',
    'fma',
    'fmax',
    'fmin',
    'fmod',
    'format',
    'frexp',
    'from_entries',
    'fromdate',
    'fromdateiso8601',
    'fromjson',
    'fromstream',
    'gamma',
    'get_jq_origin',
    'get_prog_origin',
    'get_search_list',
    'getpath',
    'gmtime',
    'group_by',
    'gsub',
    'halt',
    'halt_error',
    'has',
    'hypot',
    'implode',
    'in',
    'index',
    'indices',
    'infinite',
    'input',
    'input_filename',
    'input_line_number',
    'inputs',
    'inside',
    'isempty',
    'isfinite',
    'isinfinite',
    'isnan',
    'isnormal',
    'iterables',
    'j0',
    'j1',
    'jn',
    'join',
    'keys',
    'keys_unsorted',
    'last',
    'ldexp',
    'leaf_paths',
    'length',
    'lgamma',
    'lgamma_r',
    'limit',
    'localtime',
    'log',
    'log10',
    'log1p',
    'log2',
    'logb',
    'ltrimstr',
    'map',
    'map_values',
    'match',
    'max',
    'max_by',
    'min',
    'min_by',
    'mktime',
    'modf',
    'modulemeta',
    'nan',
    'nearbyint',
    'nextafter',
    'nexttoward',
    'normals',
    'not',
    'now',
    'nth',
    'nulls',
    'numbers',
    'objects',
    'path',
    'paths',
    'pick',
    'pow',
    'pow10',
    'range',
    'recurse',
    'recurse_down',
    'remainder',
    'repeat',
    'reverse',
    'rindex',
    'rint',
    'round',
    'rtrimstr',
    'scalars',
    'scalars_or_empty',
    'scalb',
    'scalbln',
    'scan',
    'select',
    'setpath',
    'significand',
    'sin',
    'sinh',
    'sort',
    'sort_by',
    'split',
    'splits',
    'sqrt',
    'startswith',
    'stderr',
    'strflocaltime',
    'strftime',
    'strings',
    'strptime',
    'sub',
    'tan',
    'tanh',
    'test',
    'tgamma',
    'to_entries',
    'todate',
    'todateiso8601',
    'tojson',
    'tonumber',
    'tostream',
    'tostring',
    'transpose',
    'trunc',
    'truncate_stream',
    'type',
    'unique',
    'unique_by',
    'until',
    'utf8bytelength',
    'values',
    'walk',
    'while',
    'with_entries',
    'y0',
    'y1',
    'yn',
  ].concat(['if', 'then', 'else', 'elif', 'end', 'reduce']); // missing from builtins

  const jqMode = {
    // The start state contains the rules that are initially used
    start: [
      // The regex matches the token, the token property contains the type
      { regex: /"(?:[^\\]|\\.)*?(?:"|$)/, token: 'string' },
      // You can match multiple tokens at once. Note that the captured
      // groups must span the whole string in this case
      {
        regex: /(def)(\s+)([a-z$][\w$]*)/,
        token: ['keyword', null, 'variable-2'],
      },
      // Rules are matched in the order in which they appear, so there is
      // no ambiguity between this one and the one above
      {
        regex: new RegExp(
          `\\b(?:${keywords
            .concat('def', 'if', 'elif', 'else', 'end', 'then', 'as')
            .join('|')})(?![:.])\\b`
        ),
        token: 'keyword',
      },
      { regex: /true|false|null/, token: 'atom' },
      {
        regex: /0x[a-f\d]+|[-+]?(?:\.\d+|\d+\.?\d*)(?:e[-+]?\d+)?/i,
        token: 'number',
      },
      { regex: /#.*/, token: 'comment' },
      { regex: /\/(?:[^\\]|\\.)*?\//, token: 'variable-3' },
      // A next property will cause the mode to move to a different state
      // { regex: /\/\*/, token: 'comment', next: 'comment' },
      { regex: /[-+/*=<>![\]|]+/, token: 'operator' },
      // indent and dedent properties guide autoindentation
      { regex: /[{[(]/, indent: true },
      { regex: /[}\])]/, dedent: true },
      { regex: /\$[a-z$][\w$]*/, token: 'variable' },
    ],
    // The meta property contains global information about the mode. It
    // can contain properties like lineComment, which are supported by
    // all modes, and also directives like dontIndentStates, which are
    // specific to simple modes.
    meta: {
      dontIndentStates: ['comment'],
      lineComment: '#',
    },
  };

  const sourceChange = async (cm, input) => {
    try {
      const value = getKeys(JSON.parse(cm.getValue()));
      input.addKeywordsFromString(value.join(' '));
    } catch (e) {
      // console.log('failed to parse', e);
    }
  };

  function getKeys(object) {
    return Object.keys(object).reduce((acc, curr) => {
      acc.push(curr);
      if (typeof object[curr] === 'object') {
        acc = acc.concat(getKeys(object[curr]));
      }

      return acc;
    }, []);
  }

  window.jqTools = {
    jqMode,
    sourceChange,
    keywords,
  };
})();
